<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FireFlow Pro - Advanced Sprinkler Design System</title>
    
    <!-- Custom Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <style>
        :root {
            --steel-blue: #2C3E50;
            --safety-orange: #E67E22;
            --technical-gray: #34495E;
            --success-green: #27AE60;
            --warning-amber: #F39C12;
            --error-red: #E74C3C;
            --info-blue: #3498DB;
            --charcoal: #2C2C2C;
            --medium-gray: #7F8C8D;
            --light-gray: #BDC3C7;
            --off-white: #ECF0F1;
        }
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--charcoal) 0%, var(--technical-gray) 100%);
            color: var(--off-white);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Navigation Header */
        .nav-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--technical-gray);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .nav-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
        }

        .nav-brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-logo {
            width: 32px;
            height: 32px;
            background: var(--safety-orange);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .nav-brand-text {
            color: white;
            font-weight: bold;
            font-size: 20px;
        }

        .nav-links {
            display: flex;
            gap: 8px;
        }

        .nav-link {
            color: var(--off-white);
            padding: 8px 16px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .nav-link:hover {
            color: var(--safety-orange);
            background: rgba(230, 126, 34, 0.1);
        }

        .nav-link.active {
            color: var(--safety-orange);
            background: rgba(230, 126, 34, 0.15);
        }

        .nav-link.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 16px;
            right: 16px;
            height: 2px;
            background: var(--safety-orange);
        }

        .nav-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success-green);
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .status-text {
            color: var(--off-white);
            font-size: 13px;
        }

        /* Page Container System */
        .page-container {
            display: none;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .page-container.active {
            display: block;
        }

        /* Design Studio Page (current main-container) */
        #designStudioPage {
            padding: 0;
        }

        #designStudioPage .main-container {
            margin: 20px auto;
        }

        /* Calculations Page Styles */
        .calculations-content {
            max-width: 1400px;
            margin: 0 auto;
        }

        .calculations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .calc-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .calc-section h2 {
            color: var(--off-white);
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--technical-gray);
        }

        .calc-form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .calc-form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .calc-form-group label {
            color: var(--off-white);
            font-size: 13px;
            font-weight: 500;
        }

        .calc-input {
            background: rgba(0, 0, 0, 0.3);
            color: var(--off-white);
            border: 1px solid var(--technical-gray);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .calc-input:focus {
            outline: none;
            border-color: var(--safety-orange);
            box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.2);
        }

        .calc-button-primary {
            background: var(--safety-orange);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .calc-button-primary:hover {
            background: #d35400;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.4);
        }

        .pipe-network-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .network-stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            color: var(--light-gray);
            font-size: 13px;
        }

        .stat-value {
            color: var(--safety-orange);
            font-weight: 600;
            font-size: 16px;
        }

        .pipe-size-breakdown {
            margin-top: 15px;
        }

        .pipe-size-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Graphs Section */
        .graphs-section {
            margin-top: 40px;
        }

        .graphs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }

        .graph-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .graph-container h3 {
            color: var(--off-white);
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 15px 0;
        }

        .graph-container canvas {
            max-height: 300px;
        }

        /* NFPA Compliance Section */
        .nfpa-compliance-section {
            margin-top: 40px;
        }

        .compliance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .compliance-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .compliance-status {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .compliance-status.pass {
            background: var(--success-green);
        }

        .compliance-status.fail {
            background: var(--error-red);
        }

        .compliance-status.warning {
            background: var(--warning-amber);
        }

        .compliance-text {
            flex: 1;
        }

        .compliance-text strong {
            color: var(--off-white);
            display: block;
            margin-bottom: 4px;
        }

        .compliance-text span {
            color: var(--light-gray);
            font-size: 12px;
        }

        /* Projects Page Styles */
        .projects-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }

        .project-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .project-card h3 {
            color: var(--off-white);
            margin: 0 0 10px 0;
        }

        .project-card p {
            color: var(--light-gray);
            margin: 0 0 15px 0;
        }

        /* About Page Styles */
        .about-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .about-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 30px;
        }

        .about-section h2 {
            color: var(--off-white);
            margin: 0 0 15px 0;
        }

        .about-section h3 {
            color: var(--off-white);
            margin: 20px 0 10px 0;
        }

        .about-section p {
            color: var(--light-gray);
            line-height: 1.6;
            margin: 0 0 15px 0;
        }

        .about-section ul {
            color: var(--light-gray);
            line-height: 1.8;
            padding-left: 20px;
        }

        .about-section li {
            margin-bottom: 8px;
        }

        /* Custom Scrollbar for Webkit browsers */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #2c2c2c;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Main layout container */
        .main-container {
            display: flex;
            width: 100%;
            max-width: 1600px;
            height: calc(100vh - 20px);
            margin: 10px auto;
            gap: 15px;
        }

        /* Sidebar styles */
        .sidebar {
            flex: 0 0 320px;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 100%;
        }

        .sidebar > * {
            flex-shrink: 0;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-container {
            position: relative;
            padding: 40px 0 0 40px;
            background: var(--charcoal);
            margin: 0 auto;
            border: 2px solid var(--technical-gray);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            width: 95%;
            max-width: 1200px;
            overflow: auto;
            height: calc(100vh - 150px);
        }

        #controls,
        #actions,
        #measurementForm {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 12px;
            margin: 8px 10px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            max-width: fit-content;
        }

        #measurementForm h3 {
            font-size: 14px;
            margin: 0 10px 0 0;
            white-space: nowrap;
            color: var(--off-white);
            font-weight: 600;
        }

        #measurementForm label,
        #controls label {
            margin: 0 8px;
            white-space: nowrap;
            color: var(--off-white);
            font-weight: 500;
            font-size: 13px;
        }

        #measurementForm input,
        input[type="text"],
        input[type="number"],
        input[type="file"],
        select {
            background: rgba(0, 0, 0, 0.3);
            color: var(--off-white);
            border: 1px solid var(--technical-gray);
            border-radius: 6px;
            padding: 6px 10px;
            transition: all 0.3s ease;
        }

        #measurementForm input {
            width: 50px;
            height: 28px;
            padding: 4px 8px;
            margin: 0 5px;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--safety-orange);
            box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.2);
        }

        /* Specific styling for grid/canvas control inputs */
        #gridSize, #canvasWidth, #canvasHeight, #sprinklerCoverageInput, #maxPipeSpanInput {
            width: 60px !important;
            height: 32px;
            padding: 4px 8px;
            margin: 0 5px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--off-white);
            border: 1px solid var(--technical-gray);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        #gridSize:focus, #canvasWidth:focus, #canvasHeight:focus, #sprinklerCoverageInput:focus, #maxPipeSpanInput:focus {
            border-color: var(--safety-orange);
            box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.2);
        }

        #measurementForm button {
            padding: 4px 8px;
            font-size: 11px;
            margin: 0 5px;
        }

        #controls {
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        #controls > * {
            margin: 0;
        }

        /* Better spacing for control sections within #controls */
        #controls > div {
            width: 100%;
            margin: 8px 0;
        }

        #pipeLengthContainer {
            background-color: #333; /* Dark background */
            border: 1px solid #555;
            border-radius: 8px;
            padding: 5px;
            margin: 5px auto;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            font-size: 12px;
            text-align: center;
            max-width: fit-content;
            position: relative;
            top: 20px;
        }

        button {
            background-color: var(--technical-gray);
            color: white;
            border: 1px solid var(--technical-gray);
            padding: 10px 18px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            font-weight: 600;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            background-color: var(--safety-orange);
            border-color: var(--safety-orange);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(230, 126, 34, 0.3);
        }
        
        button:active {
            transform: translateY(0px);
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.4);
        }

        button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.3);
        }

        /* Tool button active state */
        .tool-button.active,
        button.active {
            background: var(--safety-orange);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.4);
        }

        /* Special case for "danger" or "cancel" buttons */
        #cancelRoomBtn, #cancelDoorWindowBtn, #cancelInspectionBtn, #clearBackgroundBtn {
            background-color: var(--error-red);
            border-color: var(--error-red);
        }
        #cancelRoomBtn:hover, #cancelDoorWindowBtn:hover, #cancelInspectionBtn:hover, #clearBackgroundBtn:hover {
            background-color: #c0392b;
            border-color: #c0392b;
        }

        canvas {
            border: 2px solid var(--technical-gray);
            margin: 0 !important;
            display: block;
            background-color: var(--charcoal);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        #controls,
        canvas,
        ul {
            margin: 10px auto;
            text-align: center;
        }

        /* Item list tables */
        .item-list-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: hidden;
        }

        .item-list-table thead {
            background: rgba(52, 73, 94, 0.6);
            backdrop-filter: blur(10px);
        }

        .item-list-table th {
            padding: 10px 8px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            border-bottom: 2px solid var(--technical-gray);
            color: var(--off-white);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .item-list-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            vertical-align: middle;
            transition: background-color 0.2s ease;
        }

        .item-list-table tbody tr {
            transition: all 0.2s ease;
        }

        .item-list-table tbody tr:hover {
            background-color: rgba(230, 126, 34, 0.1);
            transform: translateX(2px);
        }

        .item-list-table tbody tr.selected {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.1));
            color: var(--off-white);
            border-left: 3px solid var(--success-green);
            box-shadow: 0 2px 8px rgba(39, 174, 96, 0.2);
        }

        .item-list-table tbody tr.selected input {
            color: var(--off-white);
            background-color: rgba(39, 174, 96, 0.2);
        }

        .item-list-table .editable-cell {
            cursor: text;
            min-width: 60px;
            padding: 2px 4px;
        }

        .item-list-table .editable-cell:hover {
            background-color: #4a4a4a;
        }

        .item-list-table .editable-cell:focus {
            background-color: #555;
            outline: 1px solid #4CAF50;
        }

        .item-list-table input {
            background: transparent;
            border: none;
            color: inherit;
            width: 100%;
            font-size: inherit;
            font-family: inherit;
            padding: 2px 4px;
        }

        .item-list-table input:focus {
            outline: none;
            background-color: #555;
        }

        .item-list-table button {
            background-color: #d90429;
            border-color: #ef233c;
            padding: 2px 6px;
            font-size: 10px;
            margin: 0;
        }

        .item-list-table button:hover {
            background-color: #c10324;
            border-color: #d90429;
        }

        /* Status Indicators */
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .status-active { background: var(--success-green); }
        .status-warning { background: var(--warning-amber); }
        .status-error { background: var(--error-red); }
        .status-info { background: var(--info-blue); }

        /* Gradient Text Effect */
        .gradient-text {
            background: linear-gradient(135deg, var(--safety-orange), var(--info-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Pulse Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Smooth Transitions for All Interactive Elements */
        a, button, input, select, .editable-cell {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Glass Panel Effect */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
        }

        .hover-info {
            position: absolute;
            background: #222; /* Dark hover */
            color: #e0e0e0; /* Light text */
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #555;
        }
        
        /* Sidebar sections styling */
        .sidebar-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .sidebar-section h3 {
            color: var(--off-white);
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--technical-gray);
        }

        .lists-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .list-item {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
        }

        .list-item h3 {
            color: var(--off-white);
            font-size: 15px;
            font-weight: 600;
            margin: 0 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .pipe-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .pipe-list table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        
        .pipe-list th, .pipe-list td {
            border: 1px solid #555;
            padding: 4px;
            text-align: left;
        }
        
        .pipe-list th {
            background: rgba(52, 73, 94, 0.6);
            backdrop-filter: blur(10px);
            font-weight: 600;
        }
        
        .pipe-list tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.03);
        }
        
        .pipe-list button {
            background-color: var(--error-red);
            padding: 4px 8px;
            font-size: 11px;
            transition: all 0.3s ease;
        }
        .pipe-list button:hover {
            background-color: #c0392b;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }

        .pipe-summary {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--technical-gray);
            border-radius: 8px;
            font-size: 13px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Mode display styles */
        #modeDisplay {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            border: 1px solid var(--technical-gray);
            color: var(--off-white);
            font-family: 'JetBrains Mono', monospace;
        }

        /* Container for Mode Display, Button, and Item Controls */
        .mode-controls-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            flex-wrap: wrap;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        /* Adjust button margin within the new container */
        .mode-controls-container button {
            margin: 0; /* Remove default button margin */
        }

        /* Control sections styling */
        .pipe-span-controls,
        .background-controls,
        .inspection-controls,
        .save-load-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 8px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .pipe-span-controls label,
        .background-controls label,
        .inspection-controls label {
            color: var(--off-white);
            font-size: 13px;
            margin: 0;
        }

        .background-controls button,
        .inspection-controls button,
        .save-load-controls button {
            flex: 1;
            min-width: 120px;
        }

        /* Text button styling */
        #textModeBtn {
            background-color: #17a2b8;
            border-color: #17a2b8;
            color: white;
            font-weight: bold;
        }

        #textModeBtn:hover {
            background-color: #138496;
            border-color: #117a8b;
        }

        /* Mode specific buttons container */
        .mode-specific-buttons {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Ensure item controls dropdown aligns well */
        .mode-controls-container .item-controls {
            margin: 0; /* Remove default margin if any */
            /* Add other alignment tweaks if needed */
        }

        /* Style select dropdowns */
        select {
            background-color: #444;
            color: #e0e0e0;
            border: 1px solid #666;
            padding: 6px;
            border-radius: 4px;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
            z-index: 1000;
        }
        
        /* Room dialog styles */
        .room-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2c2c2c; /* Dark dialog */
            color: #e0e0e0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 300px;
        }
        
        .room-dialog input {
            padding: 8px;
            border: 1px solid #666;
            border-radius: 4px;
            background-color: #444;
            color: #e0e0e0;
        }
        
        .room-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Door and window styles */
        .door {
            position: absolute;
            background-color: #8B4513;
            border: 1px solid #000;
            z-index: 2;
        }
        
        .window {
            position: absolute;
            background-color: rgba(135, 206, 250, 0.5);
            border: 1px solid #4682B4;
            z-index: 2;
        }

        /* Utility class to hide elements */
        .hidden {
            display: none !important; /* Use !important to override potential conflicts */
        }

        /* Lists Modal Styles */
        .lists-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .lists-modal.active {
            display: flex;
        }

        .lists-modal-content {
            background: var(--charcoal);
            border: 2px solid var(--technical-gray);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .lists-modal-header {
            background: rgba(44, 62, 80, 0.95);
            padding: 20px;
            border-bottom: 2px solid var(--technical-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .lists-modal-header h2 {
            margin: 0;
            color: var(--off-white);
            font-size: 24px;
            font-weight: 600;
        }

        .lists-modal-close {
            background: var(--error-red);
            color: white;
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .lists-modal-close:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        .lists-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }

        .lists-modal-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }

        .lists-modal-section h3 {
            margin: 0 0 15px 0;
            color: var(--off-white);
            font-size: 18px;
            font-weight: 600;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--technical-gray);
        }

        .lists-modal-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .lists-modal-table thead {
            background: rgba(52, 73, 94, 0.6);
        }

        .lists-modal-table th {
            padding: 10px 8px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--off-white);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .lists-modal-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--off-white);
        }

        .lists-modal-table tbody tr:hover {
            background-color: rgba(230, 126, 34, 0.1);
        }

        /* Hydraulics dropdown styling */
        .hydraulics-dropdown {
            margin: 5px 10px;
        }

        .hydraulics-toggle {
            width: 100%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .hydraulics-toggle:hover {
            background: linear-gradient(135deg, #45a049, #4CAF50);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .dropdown-arrow {
            transition: transform 0.3s ease;
            font-size: 12px;
        }

        .dropdown-arrow.rotated {
            transform: rotate(180deg);
        }

        .hydraulics-panel {
            background-color: #333;
            border: 1px solid #555;
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Material Database Styles */
        .material-dropdown {
            margin-bottom: 15px;
        }

        .material-toggle {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
        }

        .material-toggle:hover {
            background: #45a049;
        }

        .material-panel {
            background-color: #333;
            border: 1px solid #555;
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease-out;
            max-height: 70vh;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: #555 #333;
            position: relative;
            z-index: 10;
            width: 100%;
            box-sizing: border-box;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
        }
        
        .material-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .material-panel::-webkit-scrollbar-track {
            background: #333;
        }
        
        .material-panel::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        
        .material-panel::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .material-search {
            margin-bottom: 15px;
        }

        .material-search input {
            width: 70%;
            margin-right: 5px;
        }

        .material-categories {
            margin-bottom: 15px;
        }

        .material-list-section, .project-materials-section {
            margin-bottom: 20px;
        }

        .material-list-section h4, .project-materials-section h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .material-list {
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
            background: #1a1a1a;
            scrollbar-width: thin;
            scrollbar-color: #555 #1a1a1a;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
        }
        
        .material-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .material-list::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .material-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        
        .material-list::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .material-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: background-color 0.2s;
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
        }

        .material-item:hover {
            background: #333;
        }

        .material-item:last-child {
            border-bottom: none;
        }

        .material-info {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .material-name {
            font-weight: bold;
            color: #e0e0e0;
            font-size: 12px;
            white-space: normal;
            overflow: hidden;
            word-wrap: break-word;
            word-break: break-word;
        }

        .material-details {
            font-size: 10px;
            color: #aaa;
            margin-top: 2px;
            white-space: normal;
            overflow: hidden;
            word-wrap: break-word;
            word-break: break-word;
            text-overflow: ellipsis;
        }

        .material-price {
            color: #4CAF50;
            font-weight: bold;
            font-size: 12px;
            margin-left: 10px;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .add-material-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            margin-left: 5px;
        }

        .add-material-btn:hover {
            background: #1976D2;
        }

        .material-summary {
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .summary-row:last-child {
            margin-bottom: 0;
        }

        .summary-row span:last-child {
            color: #4CAF50;
            font-weight: bold;
        }

        .project-materials-list {
            max-height: 180px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
            background: #1a1a1a;
            scrollbar-width: thin;
            scrollbar-color: #555 #1a1a1a;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
        }
        
        .project-materials-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .project-materials-list::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .project-materials-list::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        
        .project-materials-list::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .project-material-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px;
            border-bottom: 1px solid #333;
            font-size: 11px;
            width: 100%;
            box-sizing: border-box;
            min-width: 0;
        }

        .project-material-item:last-child {
            border-bottom: none;
        }

        .project-material-info {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .project-material-quantity {
            display: flex;
            align-items: center;
            margin: 0 10px;
            flex-shrink: 0;
            min-width: 0;
        }

        .project-material-quantity input {
            width: 40px;
            margin: 0 5px;
            text-align: center;
        }

        .project-material-quantity button {
            min-width: 20px;
            padding: 2px 6px;
            font-size: 10px;
            flex-shrink: 0;
        }

        .remove-material-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .remove-material-btn:hover {
            background: #d32f2f;
        }

        .material-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            width: 100%;
            box-sizing: border-box;
        }

        .material-buttons button {
            flex: 1;
            min-width: 80px;
            max-width: 120px;
        }

        .hydraulics-inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .hydraulics-inputs label {
            font-size: 11px;
            color: #e0e0e0;
            margin-bottom: 2px;
            font-weight: bold;
        }

        .hydraulics-inputs input,
        .hydraulics-inputs select {
            font-size: 11px;
            padding: 6px;
            background-color: #444;
            color: #e0e0e0;
            border: 1px solid #666;
            border-radius: 4px;
            transition: border-color 0.3s ease;
        }

        .hydraulics-inputs input:focus,
        .hydraulics-inputs select:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 3px rgba(76, 175, 80, 0.3);
        }

        .fitting-losses-section {
            margin-top: 15px;
            padding: 10px;
            background-color: #2a2a2a;
            border-radius: 6px;
            border: 1px solid #555;
        }

        .fitting-losses-section h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 12px;
            font-weight: bold;
        }

        .fitting-losses-section h5 {
            margin: 10px 0 5px 0;
            color: #e0e0e0;
            font-size: 11px;
        }

        .fitting-controls {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            align-items: end;
            margin-bottom: 10px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
            white-space: nowrap;
        }

        .system-fittings {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
            background-color: #1a1a1a;
        }

        .fitting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 5px;
            margin: 2px 0;
            background-color: #333;
            border-radius: 3px;
            font-size: 10px;
        }

        .fitting-item button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 9px;
        }

        .fitting-item button:hover {
            background: #c82333;
        }

        .hydraulics-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .hydraulics-buttons button {
            flex: 1;
            padding: 8px;
            font-size: 11px;
        }

        /* Initially hide sprinkler coverage controls */
        .sprinkler-coverage-controls {
            display: none;
        }

        .sprinkler-coverage-controls:not(.hidden) {
            display: inline-block;
            margin-left: 10px;
        }

        /* Mini Map Styles */
        .mini-map-container {
            position: fixed; /* Changed to fixed to stay on screen */
            top: 20px;
            right: 20px;
            background-color: #2c2c2c;
            border: 2px solid #555;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            z-index: 100;
            padding: 5px;
        }

        .mini-map-header {
            background-color: #444;
            color: #e0e0e0;
            padding: 4px 8px;
            margin: -5px -5px 5px -5px;
            border-radius: 6px 6px 0 0;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            cursor: move; /* Add move cursor for dragging */
            user-select: none; /* Prevent text selection during drag */
        }

        .mini-map-header:hover {
            background-color: #555; /* Slightly lighter on hover */
        }

        #miniMapCanvas {
            border: 1px solid #666;
            display: block;
            cursor: crosshair;
            background-color: #111;
        }

        .mini-map-viewport {
            position: absolute;
            border: 2px solid #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
            pointer-events: none;
            border-radius: 2px;
        }

        /* Layer Panel Styles */
        #layerControls {
            background-color: #333;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 8px;
            margin: 5px 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #layerList {
            list-style-type: none;
            padding: 0;
            margin: 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px;
            border-bottom: 1px solid #444;
            gap: 8px;
        }

        .layer-item:last-child {
            border-bottom: none;
        }

        .layer-item.active {
            background-color: #3a86ff;
            color: white;
            border-radius: 4px;
        }

        .layer-name {
            flex-grow: 1;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .layer-name:hover {
            background-color: #444;
        }

        .layer-item button {
            padding: 2px 6px;
            font-size: 10px;
            background-color: #555;
            border: 1px solid #777;
            min-width: 20px;
        }

        .layer-item button.locked {
            background-color: #d90429;
        }

        .layer-item button:hover {
            background-color: #777;
        }

        .layer-item button[title="Rename layer"] {
            background-color: #17a2b8;
            border-color: #17a2b8;
        }

        .layer-item button[title="Rename layer"]:hover {
            background-color: #138496;
        }

        #addLayerBtn {
            width: 100%;
            margin-top: 8px;
        }

        /* Inspection Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Darker backdrop */
        }

        .modal-content {
            background-color: #2c2c2c; /* Dark modal */
            color: #e0e0e0;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #555;
            width: 80%; /* Could be more specific */
            max-width: 600px; /* Max width */
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-content h3 {
            margin-top: 0;
            text-align: center;
        }

        .modal-content label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .modal-content input[type=text],
        .modal-content input[type=date],
        .modal-content select,
        .modal-content textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            display: inline-block;
            border: 1px solid #666;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #444;
            color: #e0e0e0;
        }

        .modal-content textarea {
            height: 100px;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Close button for modal (optional) */
        /* .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-modal:hover,
        .close-modal:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        } */
    </style>
</head>

<body>
    <!-- Navigation Header -->
    <nav class="nav-header">
        <div class="nav-container">
            <div class="nav-brand">
                <div class="nav-logo">FF</div>
                <span class="nav-brand-text">FireFlow Pro</span>
            </div>
            <div class="nav-links">
                <a href="#" class="nav-link active" data-page="designStudio">Design Studio</a>
                <a href="#" class="nav-link" data-page="calculations">Calculations</a>
                <a href="#" class="nav-link" data-page="projects">Projects</a>
                <a href="#" class="nav-link" data-page="about">About</a>
            </div>
            <div class="nav-status">
                <span class="status-indicator"></span>
                <span class="status-text">System Ready</span>
            </div>
        </div>
    </nav>

    <!-- Design Studio Page -->
    <div id="designStudioPage" class="page-container active">
    <div class="main-container">
        <div class="sidebar">
            <div id="controls">
                <label for="gridSize">Grid Size:</label>
                <input type="number" id="gridSize" class="input-small" value="20" min="5">
                <label for="canvasWidth">Canvas Width:</label>
                <input type="number" id="canvasWidth" class="input-small" value="800" min="400">
                <label for="canvasHeight">Canvas Height:</label>
                <input type="number" id="canvasHeight" class="input-small" value="600" min="300">
                <button id="updateCanvas" type="button">Update Canvas</button>
                

                                
                <!-- Pipe Span Check Controls -->
                <div class="pipe-span-controls">
                    <input type="checkbox" id="checkPipeSpanToggle"/>
                    <label for="checkPipeSpanToggle">Check Max Pipe Span:</label>
                    <input type="number" id="maxPipeSpanInput" class="input-small" value="12" min="1" step="1">
                    <label for="maxPipeSpanInput">ft</label>
                </div>

                <!-- Background Image Controls -->
                <div class="background-controls">
                    <button id="loadBackgroundBtn" type="button">Load Background</button>
                    <input type="file" id="loadBackgroundInput" style="display: none;" accept="image/*" aria-label="Load background image file"/>
                    <button id="clearBackgroundBtn" type="button">Clear Background</button>
                    <!-- TODO: Add scale/offset controls later if needed -->
                </div>

                <!-- New Inspection Button -->
                <div class="inspection-controls">
                    <button id="newInspectionBtn" type="button">New Inspection</button>
                </div>

                <!-- Save/Load Controls -->
                <div class="save-load-controls">
                    <button id="saveDesignBtn" type="button">Save Design</button>
                    <button id="loadDesignBtn" type="button">Load Design</button>
                    <input type="file" id="loadDesignInput" style="display: none;" accept=".json" aria-label="Load sprinkler design file"/>
                </div>


                <!-- Hydraulics Controls -->
                <div class="hydraulics-dropdown">
                    <button id="hydraulicsToggle" class="hydraulics-toggle" onclick="toggleHydraulicsPanel()">
                        <span>Hydraulics Analysis</span>
                        <span id="hydraulicsArrow" class="dropdown-arrow"></span>
                    </button>
                    
                    <div id="hydraulicsPanel" class="hydraulics-panel" style="display: none;">
                        <div class="hydraulics-inputs">
                            <label for="pipeMaterial">Pipe Material:</label>
                            <select id="pipeMaterial" class="input-small">
                                <option value="steel">Steel (C=120)</option>
                                <option value="cast_iron">Cast Iron (C=100)</option>
                                <option value="copper">Copper (C=130)</option>
                                <option value="plastic">Plastic (C=150)</option>
                            </select>
                            
                            <label for="systemPressure">System Pressure (PSI):</label>
                            <input type="number" id="systemPressure" class="input-small" value="100" min="50" step="5">
                            
                            <label for="designDensity">Design Density (GPM/sq ft):</label>
                            <input type="number" id="designDensity" class="input-small" value="0.2" min="0.1" step="0.05">
                            
                            <label for="remoteArea">Remote Area (sq ft):</label>
                            <input type="number" id="remoteArea" class="input-small" value="1500" min="100" step="100">
                            
                            <label for="elevationHead">Elevation Head (ft):</label>
                            <input type="number" id="elevationHead" class="input-small" value="0" min="0" step="1">
                            
                            <div class="fitting-losses-section">
                                <h4>Fitting Losses</h4>
                                <div class="fitting-controls">
                                    <label for="fittingType">Fitting Type:</label>
                                    <select id="fittingType" class="input-small">
                                        <option value="">None</option>
                                        <option value="90_elbow">90 Elbow</option>
                                        <option value="45_elbow">45 Elbow</option>
                                        <option value="tee_straight">Tee (Straight)</option>
                                        <option value="tee_branch">Tee (Branch)</option>
                                        <option value="gate_valve_open">Gate Valve (Open)</option>
                                        <option value="check_valve">Check Valve</option>
                                        <option value="butterfly_valve">Butterfly Valve</option>
                                        <option value="reducer">Reducer</option>
                                    </select>
                                    
                                    <label for="fittingQuantity">Quantity:</label>
                                    <input type="number" id="fittingQuantity" class="input-small" value="1" min="0" step="1">
                                    
                                    <button onclick="addFittingToSystem()" class="btn btn-secondary btn-small">Add Fitting</button>
                                </div>
                                
                                <div id="systemFittings" class="system-fittings">
                                    <h5>System Fittings:</h5>
                                    <div id="fittingsList"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="hydraulics-buttons">
                            <button onclick="runHydraulicsAnalysis()" class="btn btn-primary">Calculate Hydraulics</button>
                            <button onclick="showHydraulicsResults()" class="btn btn-info" id="showResultsBtn" style="display:none;">View Results</button>
                        </div>
                    </div>
                </div>

                <!-- Material Database & Costing Controls -->
                <div class="material-dropdown">
                    <button id="materialToggle" class="material-toggle" onclick="toggleMaterialPanel()">
                        <span>Material Database & Costing</span>
                        <span id="materialArrow" class="dropdown-arrow"></span>
                    </button>
                    
                    <div id="materialPanel" class="material-panel" style="display: none;">
                        <div class="material-inputs">
                            <div class="material-search">
                                <label for="materialSearch">Search Materials:</label>
                                <input type="text" id="materialSearch" class="input-small" placeholder="Search by name, part number, or type">
                                <button onclick="searchMaterials()" class="btn btn-secondary btn-small">Search</button>
                            </div>
                            
                            <div class="material-categories">
                                <label for="materialCategory">Category:</label>
                                <select id="materialCategory" class="input-small" onchange="filterMaterialsByCategory()">
                                    <option value="all">All Categories</option>
                                    <option value="sprinklers">Sprinkler Heads</option>
                                    <option value="pipes">Pipes & Fittings</option>
                                    <option value="valves">Valves</option>
                                    <option value="hangers">Hangers & Supports</option>
                                    <option value="accessories">Accessories</option>
                                </select>
                            </div>
                            
                            <div class="material-list-section">
                                <h4>Available Materials</h4>
                                <div id="materialList" class="material-list">
                                    <!-- Material items will be populated here -->
                                </div>
                            </div>
                            
                            <div class="project-materials-section">
                                <h4>Project Materials</h4>
                                <div id="projectMaterials" class="project-materials">
                                    <div class="material-summary">
                                        <div class="summary-row">
                                            <span>Total Items:</span>
                                            <span id="totalItems">0</span>
                                        </div>
                                        <div class="summary-row">
                                            <span>Total Cost:</span>
                                            <span id="totalCost">$0.00</span>
                                        </div>
                                        <div class="summary-row">
                                            <span>Labor Hours:</span>
                                            <span id="totalLaborHours">0</span>
                                        </div>
                                    </div>
                                    <div id="projectMaterialsList" class="project-materials-list">
                                        <!-- Project materials will be listed here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="material-buttons">
                            <button onclick="generateMaterialList()" class="btn btn-primary">Generate Material List</button>
                            <button onclick="exportMaterialList()" class="btn btn-info">Export to Excel</button>
                            <button onclick="clearProjectMaterials()" class="btn btn-warning">Clear All</button>
                        </div>
                    </div>
                </div>

                <!-- Dedicated Mode Buttons (Optional - Text Mode Example) -->
                <div class="mode-specific-buttons">
                    <button id="textModeBtn" type="button" title="Text Annotation Mode">Text</button>
                    <!-- Add other dedicated mode buttons here if desired -->
                </div>

                <button id="undoBtn" type="button">Undo</button>
                <button id="redoBtn" type="button">Redo</button>
                <button id="generateReportBtn" type="button">Generate Report</button>
                <button id="viewAllListsBtn" type="button" style="background-color: var(--info-blue);">View All Lists</button>
            </div>

            <!-- Container for Mode Display, Toggle Button, and Item Selection -->
            <div class="mode-controls-container">
                <button id="toggleMode" type="button">Change Mode</button> 
            <div id="modeDisplay">Mode: pipe</div>

                <!-- Pipe Size Selection -->
                <div class="pipe-size-controls">
                    <label for="pipeSize">Pipe Size:</label>
                    <select id="pipeSize" class="input-small">
                        <option value="1/2&quot;">1/2"</option>
                        <option value="3/4&quot;">3/4"</option>
                        <option value="1&quot;">1"</option>
                        <option value="1-1/4&quot;">1-1/4"</option>
                        <option value="1-1/2&quot;">1-1/2"</option>
                        <option value="2&quot;">2"</option>
                    </select>
                </div>

                <!-- Item Selection Dropdown -->
                <div class="item-controls hidden">
                    <label for="itemSelect">Place Item:</label>
                    <select id="itemSelect" class="input-small">
                        <option value="sprinkler" selected>Sprinkler</option>
                        <option value="extinguisher">Extinguisher</option>
                        <option value="valve">Valve</option>
                        <option value="pullStation">Pull Station</option>
                        <option value="flowSwitch">Flow Switch</option>
                        <option value="pressureGauge">Pressure Gauge</option>
                    </select>
                    
                    <!-- Default Coverage Controls (Only for Sprinkler) -->
                    <div class="sprinkler-coverage-controls"> 
                        <label for="sprinklerCoverageInput">Default Coverage (ft):</label>
                        <input type="number" id="sprinklerCoverageInput" class="input-small" value="15" min="5" step="1">
                    </div>
                </div>

                <!-- Door/Window Controls -->
                <div class="door-window-controls hidden">
                    <button id="addDoorBtn" type="button">Add Door</button>
                    <button id="addWindowBtn" type="button">Add Window</button>
                </div>
            </div>
            <!-- End Container -->


            <!-- Layer Controls -->
            <div id="layerControls" class="sidebar-section">
                <h3>Layers</h3>
                <ul id="layerList">
                    <!-- Layer items will be populated by JS -->
                </ul>
                <button id="addLayerBtn" type="button">Add New Layer</button>
            </div>

            <div class="lists-container">
                <div class="list-item">
                    <h3>Pipe List</h3>
                    <div class="pipe-list">
                        <table id="pipeList">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Size</th>
                                    <th>Length (ft)</th>
                                    <th>Name</th>
                                    <th>From</th>
                                    <th>To</th>
                                    <th></th> <!-- Cell for delete button -->
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Pipe items will be added here -->
                            </tbody>
                        </table>
                    </div>
                    <div id="pipeSummary" class="pipe-summary">
                        <!-- Pipe summary will be added here -->
                    </div>
                </div>
                
                <div class="list-item">
                    <h3>Fire Extinguishers</h3>
                    <table class="item-list-table">
                        <thead>
                            <tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th><th></th></tr>
                        </thead>
                        <tbody id="extinguisherList"></tbody>
                    </table>
                </div>
                <div class="list-item">
                    <h3>Sprinklers</h3>
                    <table class="item-list-table">
                        <thead>
                            <tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th><th></th></tr>
                        </thead>
                        <tbody id="sprinklerList"></tbody>
                    </table>
                </div>
                <!-- Add sections for new items -->
                <div class="list-item">
                    <h3>Valves</h3>
                    <table class="item-list-table">
                        <thead>
                            <tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th><th></th></tr>
                        </thead>
                        <tbody id="valveList"></tbody>
                    </table>
                </div>
                <div class="list-item">
                    <h3>Pull Stations</h3>
                    <table class="item-list-table">
                        <thead>
                            <tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th><th></th></tr>
                        </thead>
                        <tbody id="pullStationList"></tbody>
                    </table>
                </div>
                <div class="list-item">
                    <h3>Flow Switches</h3>
                    <table class="item-list-table">
                        <thead>
                            <tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th><th></th></tr>
                        </thead>
                        <tbody id="flowSwitchList"></tbody>
                    </table>
                </div>
                <div class="list-item">
                    <h3>Pressure Gauges</h3>
                    <table class="item-list-table">
                        <thead>
                            <tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th><th></th></tr>
                        </thead>
                        <tbody id="pressureGaugeList"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
                
                <!-- Mini Map -->
                <div id="miniMapContainer" class="mini-map-container" style="display: none;">
                    <div class="mini-map-header">Mini Map</div>
                    <canvas id="miniMapCanvas" width="200" height="150"></canvas>
                    <div class="mini-map-viewport"></div>
                </div>
            </div>
        </div>
    </div>
    </div>
    <!-- End Design Studio Page -->

    <!-- Calculations Page -->
    <div id="calculationsPage" class="page-container">
        <div class="calculations-content">
            <h1 style="color: var(--off-white); margin-bottom: 30px; font-size: 28px;">System Performance Analysis</h1>
            
            <div class="calculations-grid">
                <!-- System Parameters Section -->
                <div class="calc-section">
                    <h2>System Parameters</h2>
                    <div class="calc-form-grid">
                        <div class="calc-form-group">
                            <label>System Type:</label>
                            <select id="calcSystemType" class="calc-input">
                                <option value="wet">Wet Pipe System</option>
                                <option value="dry">Dry Pipe System</option>
                                <option value="preaction">Pre-Action System</option>
                                <option value="deluge">Deluge System</option>
                            </select>
                        </div>
                        <div class="calc-form-group">
                            <label>Hazard Classification:</label>
                            <select id="calcHazardClass" class="calc-input">
                                <option value="light">Light Hazard</option>
                                <option value="ordinary">Ordinary Hazard</option>
                                <option value="extra">Extra Hazard</option>
                            </select>
                        </div>
                        <div class="calc-form-group">
                            <label>Supply Pressure (PSI):</label>
                            <input type="number" id="calcSupplyPressure" class="calc-input" value="100" min="50" step="5">
                        </div>
                        <div class="calc-form-group">
                            <label>Design Density (GPM/sq ft):</label>
                            <input type="number" id="calcDesignDensity" class="calc-input" value="0.2" min="0.1" step="0.05">
                        </div>
                        <div class="calc-form-group">
                            <label>Remote Area (sq ft):</label>
                            <input type="number" id="calcRemoteArea" class="calc-input" value="1500" min="100" step="100">
                        </div>
                        <div class="calc-form-group">
                            <label>Pipe Material:</label>
                            <select id="calcPipeMaterial" class="calc-input">
                                <option value="steel">Steel (C=120)</option>
                                <option value="cast_iron">Cast Iron (C=100)</option>
                                <option value="copper">Copper (C=130)</option>
                                <option value="plastic">Plastic (C=150)</option>
                            </select>
                        </div>
                        <div class="calc-form-group">
                            <label>Elevation Head (ft):</label>
                            <input type="number" id="calcElevationHead" class="calc-input" value="0" min="0" step="1">
                        </div>
                        <div class="calc-form-group">
                            <label>Water Temperature (F):</label>
                            <input type="number" id="calcWaterTemp" class="calc-input" value="60" min="32" step="1">
                        </div>
                    </div>
                    <button id="calcUpdateBtn" class="calc-button-primary" onclick="updateCalculations()">Calculate System Performance</button>
                </div>

                <!-- Sprinkler Specifications Section -->
                <div class="calc-section">
                    <h2>Sprinkler Specifications</h2>
                    <div class="calc-form-grid">
                        <div class="calc-form-group">
                            <label>Sprinkler Type:</label>
                            <select id="calcSprinklerType" class="calc-input">
                                <option value="pendant">Pendant</option>
                                <option value="upright">Upright</option>
                                <option value="sidewall">Sidewall</option>
                                <option value="concealed">Concealed</option>
                            </select>
                        </div>
                        <div class="calc-form-group">
                            <label>K-Factor:</label>
                            <input type="number" id="calcKFactor" class="calc-input" value="5.6" min="1.4" step="0.1">
                        </div>
                        <div class="calc-form-group">
                            <label>Operating Pressure (PSI):</label>
                            <input type="number" id="calcOperatingPressure" class="calc-input" value="50" min="7" step="1">
                        </div>
                        <div class="calc-form-group">
                            <label>Coverage Area (sq ft):</label>
                            <input type="number" id="calcCoverageArea" class="calc-input" value="130" min="50" step="10">
                        </div>
                        <div class="calc-form-group">
                            <label>Spacing (ft):</label>
                            <input type="number" id="calcSpacing" class="calc-input" value="12" min="8" step="1">
                        </div>
                        <div class="calc-form-group">
                            <label>Response Time:</label>
                            <select id="calcResponseTime" class="calc-input">
                                <option value="fast">Fast Response</option>
                                <option value="standard">Standard Response</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Pipe Network Section -->
                <div class="calc-section">
                    <h2>Pipe Network</h2>
                    <div class="pipe-network-info">
                        <div class="network-stat">
                            <span class="stat-label">Total Pipes:</span>
                            <span class="stat-value" id="calcTotalPipes">0</span>
                        </div>
                        <div class="network-stat">
                            <span class="stat-label">Total Length:</span>
                            <span class="stat-value" id="calcTotalLength">0 ft</span>
                        </div>
                        <div class="network-stat">
                            <span class="stat-label">Average Pipe Size:</span>
                            <span class="stat-value" id="calcAvgPipeSize">N/A</span>
                        </div>
                        <div class="network-stat">
                            <span class="stat-label">Total Fittings:</span>
                            <span class="stat-value" id="calcTotalFittings">0</span>
                        </div>
                    </div>
                    <div class="pipe-size-breakdown" id="pipeSizeBreakdown">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Performance Analysis Graphs -->
            <div class="graphs-section">
                <h2 style="color: var(--off-white); margin-bottom: 20px;">Performance Analysis</h2>
                <div class="graphs-grid">
                    <div class="graph-container">
                        <h3>Pressure Distribution</h3>
                        <canvas id="pressureChart"></canvas>
                    </div>
                    <div class="graph-container">
                        <h3>Flow Rate Analysis</h3>
                        <canvas id="flowRateChart"></canvas>
                    </div>
                    <div class="graph-container">
                        <h3>Friction Loss</h3>
                        <canvas id="frictionLossChart"></canvas>
                    </div>
                    <div class="graph-container">
                        <h3>Coverage Analysis</h3>
                        <canvas id="coverageChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- NFPA Compliance Section -->
            <div class="nfpa-compliance-section">
                <h2 style="color: var(--off-white); margin-bottom: 20px;">NFPA Requirements Compliance</h2>
                <div class="compliance-grid" id="nfpaComplianceGrid">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Projects Page -->
    <div id="projectsPage" class="page-container">
        <div class="projects-content">
            <h1 style="color: var(--off-white); margin-bottom: 30px; font-size: 28px;">Projects</h1>
            <div class="projects-grid" id="projectsGrid">
                <div class="project-card">
                    <h3>Current Project</h3>
                    <p>Your active design project</p>
                    <button class="calc-button-primary" onclick="switchToPage('designStudio')">Open Design</button>
                </div>
                <!-- More projects can be added here -->
            </div>
        </div>
    </div>

    <!-- About Page -->
    <div id="aboutPage" class="page-container">
        <div class="about-content">
            <h1 style="color: var(--off-white); margin-bottom: 30px; font-size: 28px;">About FireFlow Pro</h1>
            <div class="about-section">
                <h2>Advanced Sprinkler Design System</h2>
                <p>FireFlow Pro is a comprehensive fire protection system design and analysis tool that helps engineers create compliant sprinkler system designs.</p>
                <h3>Features</h3>
                <ul>
                    <li>Interactive design canvas with grid-based layout</li>
                    <li>Comprehensive material database and costing</li>
                    <li>Hydraulic calculations and analysis</li>
                    <li>NFPA compliance checking</li>
                    <li>Performance visualization and reporting</li>
                </ul>
                <h3>Version</h3>
                <p>Version 1.0.0</p>
            </div>
        </div>
    </div>

    <!-- Add toast container -->
    <div id="toast" class="toast"></div>
    
    <!-- Room dialog -->
    <div id="roomDialog" class="room-dialog" style="display: none;">
        <h3>Room Properties</h3>
        <div>
            <label for="roomName">Room Name:</label>
            <input type="text" id="roomName" placeholder="Enter room name">
        </div>
        <div class="room-dialog-buttons">
            <button id="cancelRoomBtn" type="button">Cancel</button>
            <button id="saveRoomBtn" type="button">Save Room</button>
        </div>
    </div>
    
    <!-- Door/Window dialog -->
    <div id="doorWindowDialog" class="room-dialog" style="display: none;">
        <h3>Add Door/Window</h3>
        <div>
            <label>
                <input type="radio" name="doorWindowType" value="door" checked> Door
            </label>
            <label>
                <input type="radio" name="doorWindowType" value="window"> Window
            </label>
        </div>
        <div>
            <label for="doorWindowWidth">Width (ft):</label>
            <input type="number" id="doorWindowWidth" value="3" min="1" max="10" step="0.5">
        </div>
        <div class="room-dialog-buttons">
            <button id="cancelDoorWindowBtn" type="button">Cancel</button>
            <button id="saveDoorWindowBtn" type="button">Add</button>
        </div>
    </div>

        <!-- Inspection Modal -->
        <div id="inspectionModal" class="modal">
            <div class="modal-content">
                <h3>New Inspection Report</h3>
                
                <div>
                    <label for="inspectionTemplate">Load Template:</label>
                    <select id="inspectionTemplate">
                        <option value="generic-form">-- New Blank Report --</option>
                        <!-- Templates will be populated by JS -->
                    </select>
                </div>
    
                <!-- This div will hold the loaded form template -->
                <div id="inspectionFormContainer">
                    <!-- Content will be loaded here by JS -->
                </div>
    
                <div class="modal-buttons">
                    <button id="cancelInspectionBtn" type="button">Cancel</button>
                    <button id="saveInspectionBtn" type="button">Save Inspection</button>
                </div>
            </div>
        </div>

    <!-- All Lists Modal -->
    <div id="allListsModal" class="lists-modal" onclick="handleListsModalClick(event)">
        <div class="lists-modal-content" onclick="event.stopPropagation()">
            <div class="lists-modal-header">
                <h2>All Lists Overview</h2>
                <button class="lists-modal-close" onclick="closeAllListsModal()">&times;</button>
            </div>
            <div class="lists-modal-body" id="allListsModalBody">
                <!-- Lists will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Hover info display -->
    <div id="hoverInfo" class="hover-info" style="display: none;"></div>

    <!-- Hidden div to store form templates -->
    <div id="formTemplates" style="display: none;">

        <!-- The original generic form is now a template -->
        <div data-template-id="generic-form">
            <div>
                <label for="inspectionType">Inspection Type:</label>
                <select id="inspectionType" name="inspectionType">
                    <option value="General">General</option>
                    <option value="Weekly">Weekly</option>
                    <option value="Monthly">Monthly</option>
                    <option value="Quarterly">Quarterly</option>
                    <option value="Annual">Annual</option>
                    <option value="Other">Other</option>
                </select>
            </div>
            <div>
                <label for="inspectionDate">Date:</label>
                <input type="date" id="inspectionDate" name="inspectionDate">
            </div>
            <div>
                <label for="inspectorName">Inspector:</label>
                <input type="text" id="inspectorName" name="inspectorName" placeholder="Enter inspector name">
            </div>
            <div>
                <label for="inspectionLocation">Location/Site:</label>
                <input type="text" id="inspectionLocation" name="inspectionLocation" placeholder="Enter site name or description">
            </div>
            <div>
                <label for="inspectionNotes">Notes / Deficiencies:</label>
                <textarea id="inspectionNotes" name="inspectionNotes" placeholder="Enter general notes or list deficiencies..."></textarea>
            </div>
        </div>

        <!-- A new, specific template for a pump inspection -->
        <div data-template-id="quarterly-pumps">
            <h4>Quarterly Fire Pump Checklist</h4>
            <p><strong>Location:</strong> Main Pump Room</p>
            <div>
                <label for="pump-inspector">Inspector:</label>
                <input type="text" id="pump-inspector" name="inspector" placeholder="Enter inspector name">
            </div>
            <div>
                <label for="pump-date">Date:</label>
                <input type="date" id="pump-date" name="inspectionDate">
            </div>
            <hr>
            <label><input type="checkbox" name="pump_casing_leaks"> Pump casing is free of leaks.</label><br>
            <label><input type="checkbox" name="gauges_good"> Suction/discharge gauges in good condition.</label><br>
            <label><input type="checkbox" name="pump_running_test"> Weekly run test performed.</label><br>
            <label>Notes:</label><br>
            <textarea name="pump_notes" style="width: 95%;" rows="3"></textarea>
        </div>

        <!-- Another new template -->
        <div data-template-id="annual-sprinklers">
             <h4>Annual Sprinkler System Walk-through</h4>
             <p><strong>Location:</strong> All Floors</p>
            <div>
                <label for="sprinkler-inspector">Inspector:</label>
                <input type="text" id="sprinkler-inspector" name="inspector" placeholder="Enter inspector name">
            </div>
             <div>
                <label for="sprinkler-date">Date:</label>
                <input type="date" id="sprinkler-date" name="inspectionDate">
             </div>
             <hr>
            <label><input type="checkbox" name="head_clearance"> All sprinkler heads have 18" vertical clearance.</label><br>
            <label><input type="checkbox" name="head_condition"> All heads free of paint, corrosion, or damage.</label><br>
            <label><input type="checkbox" name="spare_heads_stocked"> Spare head cabinet is properly stocked.</label><br>
             <label>Notes:</label><br>
             <textarea name="sprinkler_notes" style="width: 95%;" rows="3"></textarea>
        </div>

    </div>

    <script>
        // ===== HYDRAULICS CALCULATIONS =====
        const hydraulics = {
            // Hazen-Williams coefficients for different pipe materials
            hazenWilliamsCoeffs: {
                'steel': 120,
                'cast_iron': 100,
                'copper': 130,
                'plastic': 150
            },
            
            // Pipe diameter conversions (inches to feet)
            pipeDiameters: {
                '1/2"': 0.5/12,
                '3/4"': 0.75/12,
                '1"': 1/12,
                '1-1/4"': 1.25/12,
                '1-1/2"': 1.5/12,
                '2"': 2/12
            },
            
            // Sprinkler K-factors (GPM per PSI^0.5)
            sprinklerKFactors: {
                'standard': 5.6,
                'extended_coverage': 8.0,
                'early_suppression': 11.2,
                'high_challenge': 14.0
            },
            
            // Fitting loss coefficients (K-factors)
            fittingLossCoeffs: {
                // Elbows (90-degree)
                '90_elbow': {
                    '1/2"': 0.9,
                    '3/4"': 0.9,
                    '1"': 0.9,
                    '1-1/4"': 0.9,
                    '1-1/2"': 0.9,
                    '2"': 0.9
                },
                // 45-degree elbows
                '45_elbow': {
                    '1/2"': 0.4,
                    '3/4"': 0.4,
                    '1"': 0.4,
                    '1-1/4"': 0.4,
                    '1-1/2"': 0.4,
                    '2"': 0.4
                },
                // Tees (straight through)
                'tee_straight': {
                    '1/2"': 0.2,
                    '3/4"': 0.2,
                    '1"': 0.2,
                    '1-1/4"': 0.2,
                    '1-1/2"': 0.2,
                    '2"': 0.2
                },
                // Tees (branch)
                'tee_branch': {
                    '1/2"': 1.8,
                    '3/4"': 1.8,
                    '1"': 1.8,
                    '1-1/4"': 1.8,
                    '1-1/2"': 1.8,
                    '2"': 1.8
                },
                // Gate valves (fully open)
                'gate_valve_open': {
                    '1/2"': 0.19,
                    '3/4"': 0.19,
                    '1"': 0.19,
                    '1-1/4"': 0.19,
                    '1-1/2"': 0.19,
                    '2"': 0.19
                },
                // Check valves
                'check_valve': {
                    '1/2"': 2.5,
                    '3/4"': 2.5,
                    '1"': 2.5,
                    '1-1/4"': 2.5,
                    '1-1/2"': 2.5,
                    '2"': 2.5
                },
                // Butterfly valves
                'butterfly_valve': {
                    '1/2"': 0.3,
                    '3/4"': 0.3,
                    '1"': 0.3,
                    '1-1/4"': 0.3,
                    '1-1/2"': 0.3,
                    '2"': 0.3
                },
                // Reducers
                'reducer': {
                    '1/2"': 0.05,
                    '3/4"': 0.05,
                    '1"': 0.05,
                    '1-1/4"': 0.05,
                    '1-1/2"': 0.05,
                    '2"': 0.05
                }
            }
        };

        // ===== STATE MANAGEMENT =====
        const state = {
            mode: 'pipe',
            // Add currentItemType state
            currentItemType: 'sprinkler', // Default to sprinkler as it's selected in HTML
            isDrawing: false,
            layers: [],
            activeLayerId: null,

            currentRoom: { points: [], name: '' },
            isDrawingRoom: false,
            selectedWall: null,
            editingWall: null,
            selectedText: null,
            draggingText: false,
            selectedItem: null, // For highlighting items from table clicks
            undoStack: [],
            redoStack: [],
            showMiniMap: false,
            currentMouseX: null,
            currentMouseY: null,
            // Add coverage state
            sprinklerCoverageFt: 15,
            // Add double-click flag
            processingDoubleClick: false,
            // Add text annotations array
            texts: [],
            // Add visibility state
            visibility: {
                grid: true,
                miniMap: false
            },
            // Add pipe span check state
            checkPipeSpan: false,
            maxPipeSpanFt: 12,
            // Add inspections array
            inspections: [],
            // Add background image state
            backgroundImage: null,
            backgroundImageSrc: null,
            // Add hydraulics state
            hydraulics: {
                pipeMaterial: 'steel',
                systemPressure: 100, // PSI
                designDensity: 0.2, // GPM/sq ft
                remoteArea: 1500, // sq ft
                elevationHead: 0, // ft
                calculated: false,
                results: null,
                systemFittings: [] // Array of fittings added to the system
            },
            // Add material database state
            materials: {
                projectMaterials: [], // Array of materials added to current project
                searchTerm: '',
                selectedCategory: 'all',
                materialDatabase: [] // Will be populated with comprehensive material data
            }
        };

        // Tolerance for clicking near an existing item (pixels)
        const CLICK_NEAR_ITEM_TOLERANCE = 10;

        // ===== DOM ELEMENTS =====
        const elements = {};

        // ===== HELPER FUNCTIONS =====
        
        /**
         * Get mouse position relative to the canvas element.
         */
        function getCanvasCoordinates(e) {
            const rect = elements.canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        /**
         * Get mouse position relative to canvas
         */
        function getMousePos(canvas, evt) {
            try {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            } catch (error) {
                console.error('Error getting mouse position:', error);
                return { x: 0, y: 0 };
            }
        }

        /**
         * Get grid coordinates based on mouse position
         */
        function getGridCoordinates(x, y) {
            try {
                const gridSize = parseInt(elements.gridSizeInput.value);
                const translationOffset = 20; // The amount the canvas context is translated

                // Adjust for the translation to get coordinates relative to the grid origin
                const translatedX = x - translationOffset;
                const translatedY = y - translationOffset;
                
                // Snap to grid
                const gridX = Math.round(translatedX / gridSize) * gridSize;
                const gridY = Math.round(translatedY / gridSize) * gridSize;
                
                return { x: gridX, y: gridY };
            } catch (error) {
                console.error('Error getting grid coordinates:', error);
                return { x: x, y: y }; // Return original coordinates on error
            }
        }

        /**
         * Calculate distance between two points
         */
        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        /**
         * Calculate friction head loss using Hazen-Williams equation
         * @param {number} flow - Flow rate in GPM
         * @param {number} length - Pipe length in feet
         * @param {string} pipeSize - Pipe size (e.g., "1"", "2"")
         * @param {number} c - Hazen-Williams coefficient
         * @returns {number} Friction head loss in feet
         */
        function calculateFrictionLoss(flow, length, pipeSize, c) {
            const diameter = hydraulics.pipeDiameters[pipeSize];
            if (!diameter) return 0;
            
            // Hazen-Williams equation: hf = 4.52 * Q^1.85 * L / (C^1.85 * D^4.87)
            const hf = 4.52 * Math.pow(flow, 1.85) * length / (Math.pow(c, 1.85) * Math.pow(diameter, 4.87));
            return hf;
        }

        /**
         * Calculate sprinkler head flow rate using K-factor
         * @param {number} pressure - Pressure at sprinkler in PSI
         * @param {number} kFactor - Sprinkler K-factor
         * @returns {number} Flow rate in GPM
         */
        function calculateSprinklerFlow(pressure, kFactor) {
            // Q = K * sqrt(P)
            return kFactor * Math.sqrt(pressure);
        }

        /**
         * Calculate required pressure for desired flow rate
         * @param {number} flow - Desired flow rate in GPM
         * @param {number} kFactor - Sprinkler K-factor
         * @returns {number} Required pressure in PSI
         */
        function calculateRequiredPressure(flow, kFactor) {
            // P = (Q / K)^2
            return Math.pow(flow / kFactor, 2);
        }

        /**
         * Convert head loss to pressure loss
         * @param {number} headLoss - Head loss in feet
         * @returns {number} Pressure loss in PSI
         */
        function headToPressure(headLoss) {
            // 1 PSI = 2.31 feet of head
            return headLoss / 2.31;
        }

        /**
         * Convert pressure to head
         * @param {number} pressure - Pressure in PSI
         * @returns {number} Head in feet
         */
        function pressureToHead(pressure) {
            return pressure * 2.31;
        }

        /**
         * Calculate total system flow requirements
         * @param {number} designDensity - Design density in GPM/sq ft
         * @param {number} remoteArea - Remote area in sq ft
         * @returns {number} Total required flow in GPM
         */
        function calculateSystemFlow(designDensity, remoteArea) {
            return designDensity * remoteArea;
        }

        /**
         * Calculate fitting head loss using K-factor method
         * @param {number} flow - Flow rate in GPM
         * @param {string} pipeSize - Pipe size (e.g., "1"", "2"")
         * @param {string} fittingType - Type of fitting (e.g., "90_elbow", "tee_branch")
         * @param {number} quantity - Number of fittings (default: 1)
         * @returns {number} Fitting head loss in feet
         */
        function calculateFittingLoss(flow, pipeSize, fittingType, quantity = 1) {
            const kFactor = hydraulics.fittingLossCoeffs[fittingType]?.[pipeSize];
            if (!kFactor) return 0;
            
            const diameter = hydraulics.pipeDiameters[pipeSize];
            if (!diameter) return 0;
            
            // Calculate velocity: V = Q / ( * D / 4) * 144 (to convert from sq ft to sq in)
            const velocity = flow / (Math.PI * Math.pow(diameter, 2) / 4) * 144;
            
            // Fitting head loss: hf = K * (V / 2g) * quantity
            // Where g = 32.2 ft/s and V is in ft/s
            const headLoss = kFactor * (Math.pow(velocity, 2) / (2 * 32.2)) * quantity;
            
            return headLoss;
        }

        /**
         * Calculate equivalent length for fitting losses
         * @param {string} pipeSize - Pipe size (e.g., "1"", "2"")
         * @param {string} fittingType - Type of fitting
         * @param {number} quantity - Number of fittings
         * @returns {number} Equivalent length in feet
         */
        function calculateEquivalentLength(pipeSize, fittingType, quantity = 1) {
            // Standard equivalent lengths for common fittings (in feet)
            const equivalentLengths = {
                '90_elbow': { '1/2"': 1.5, '3/4"': 2.0, '1"': 2.5, '1-1/4"': 3.5, '1-1/2"': 4.0, '2"': 5.0 },
                '45_elbow': { '1/2"': 0.8, '3/4"': 1.0, '1"': 1.3, '1-1/4"': 1.8, '1-1/2"': 2.0, '2"': 2.5 },
                'tee_straight': { '1/2"': 0.3, '3/4"': 0.4, '1"': 0.5, '1-1/4"': 0.7, '1-1/2"': 0.8, '2"': 1.0 },
                'tee_branch': { '1/2"': 3.0, '3/4"': 4.0, '1"': 5.0, '1-1/4"': 7.0, '1-1/2"': 8.0, '2"': 10.0 },
                'gate_valve_open': { '1/2"': 0.4, '3/4"': 0.5, '1"': 0.7, '1-1/4"': 0.9, '1-1/2"': 1.0, '2"': 1.3 },
                'check_valve': { '1/2"': 5.0, '3/4"': 6.5, '1"': 8.5, '1-1/4"': 12.0, '1-1/2"': 14.0, '2"': 17.0 },
                'butterfly_valve': { '1/2"': 0.6, '3/4"': 0.8, '1"': 1.0, '1-1/4"': 1.4, '1-1/2"': 1.6, '2"': 2.0 },
                'reducer': { '1/2"': 0.1, '3/4"': 0.1, '1"': 0.2, '1-1/4"': 0.2, '1-1/2"': 0.3, '2"': 0.3 }
            };
            
            const eqLength = equivalentLengths[fittingType]?.[pipeSize] || 0;
            return eqLength * quantity;
        }

        /**
         * Calculate total friction loss including fittings
         * @param {number} flow - Flow rate in GPM
         * @param {number} pipeLength - Pipe length in feet
         * @param {string} pipeSize - Pipe size
         * @param {number} c - Hazen-Williams coefficient
         * @param {Array} fittings - Array of fitting objects {type, quantity}
         * @returns {number} Total friction head loss in feet
         */
        function calculateTotalFrictionLoss(flow, pipeLength, pipeSize, c, fittings = []) {
            // Calculate straight pipe friction loss
            let totalLoss = calculateFrictionLoss(flow, pipeLength, pipeSize, c);
            
            // Add fitting losses
            fittings.forEach(fitting => {
                const fittingLoss = calculateFittingLoss(flow, pipeSize, fitting.type, fitting.quantity);
                totalLoss += fittingLoss;
            });
            
            return totalLoss;
        }

        /**
         * Perform comprehensive hydraulics analysis of the sprinkler system
         * @returns {object} Hydraulics analysis results
         */
        function performHydraulicsAnalysis() {
            const results = {
                totalFlow: 0,
                totalPressureLoss: 0,
                pipeSegments: [],
                sprinklerAnalysis: [],
                systemSummary: {},
                warnings: [],
                errors: []
            };

            try {
                // Get all pipes from all layers
                const allPipes = [];
                state.layers.forEach(layer => {
                    if (layer.pipes) {
                        allPipes.push(...layer.pipes);
                    }
                });

                // Get all sprinklers from all layers
                const allSprinklers = [];
                state.layers.forEach(layer => {
                    if (layer.items) {
                        allSprinklers.push(...layer.items.filter(item => item.type === 'sprinkler'));
                    }
                });

                if (allPipes.length === 0) {
                    results.warnings.push("No pipes found in the design");
                    return results;
                }

                if (allSprinklers.length === 0) {
                    results.warnings.push("No sprinklers found in the design");
                    return results;
                }

                const gridSize = parseInt(elements.gridSizeInput.value);
                const c = hydraulics.hazenWilliamsCoeffs[state.hydraulics.pipeMaterial];
                
                // Calculate system flow requirements
                results.totalFlow = calculateSystemFlow(state.hydraulics.designDensity, state.hydraulics.remoteArea);
                
                // Analyze each pipe segment
                allPipes.forEach((pipe, index) => {
                    const length = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2) / gridSize; // Convert to feet
                    
                    // Calculate friction loss including fittings
                    const totalFrictionLoss = calculateTotalFrictionLoss(
                        results.totalFlow, 
                        length, 
                        pipe.size, 
                        c, 
                        state.hydraulics.systemFittings
                    );
                    
                    const pressureLoss = headToPressure(totalFrictionLoss);
                    
                    // Calculate fitting losses separately for reporting
                    let totalFittingLoss = 0;
                    state.hydraulics.systemFittings.forEach(fitting => {
                        totalFittingLoss += calculateFittingLoss(results.totalFlow, pipe.size, fitting.type, fitting.quantity);
                    });
                    
                    results.pipeSegments.push({
                        index: index + 1,
                        size: pipe.size,
                        length: length.toFixed(2),
                        flow: results.totalFlow,
                        frictionLoss: totalFrictionLoss.toFixed(2),
                        fittingLoss: headToPressure(totalFittingLoss).toFixed(2),
                        pressureLoss: pressureLoss.toFixed(2),
                        coordinates: `${Math.floor(pipe.x1/gridSize)},${Math.floor(pipe.y1/gridSize)} to ${Math.floor(pipe.x2/gridSize)},${Math.floor(pipe.y2/gridSize)}`
                    });
                    
                    results.totalPressureLoss += pressureLoss;
                });

                // Analyze sprinkler performance
                const kFactor = hydraulics.sprinklerKFactors.standard;
                const availablePressure = state.hydraulics.systemPressure - results.totalPressureLoss;
                
                allSprinklers.forEach((sprinkler, index) => {
                    const flow = calculateSprinklerFlow(availablePressure, kFactor);
                    const requiredPressure = calculateRequiredPressure(results.totalFlow / allSprinklers.length, kFactor);
                    
                    results.sprinklerAnalysis.push({
                        index: index + 1,
                        pressure: availablePressure.toFixed(1),
                        actualFlow: flow.toFixed(2),
                        requiredFlow: (results.totalFlow / allSprinklers.length).toFixed(2),
                        requiredPressure: requiredPressure.toFixed(1),
                        adequate: flow >= (results.totalFlow / allSprinklers.length),
                        coordinates: `${Math.floor(sprinkler.x/gridSize)},${Math.floor(sprinkler.y/gridSize)}`
                    });
                });

                // System summary
                results.systemSummary = {
                    totalPipes: allPipes.length,
                    totalSprinklers: allSprinklers.length,
                    totalPipeLength: allPipes.reduce((sum, pipe) => {
                        return sum + calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2) / gridSize;
                    }, 0).toFixed(2),
                    systemFlow: results.totalFlow.toFixed(1),
                    totalPressureLoss: results.totalPressureLoss.toFixed(1),
                    availablePressure: (state.hydraulics.systemPressure - results.totalPressureLoss).toFixed(1),
                    systemAdequate: (state.hydraulics.systemPressure - results.totalPressureLoss) > 0
                };

                // Add warnings and errors
                if (results.totalPressureLoss > state.hydraulics.systemPressure * 0.8) {
                    results.warnings.push("High pressure loss detected - consider larger pipe sizes");
                }
                
                if (!results.systemSummary.systemAdequate) {
                    results.errors.push("System pressure insufficient - increase supply pressure or reduce friction losses");
                }

                const inadequateSprinklers = results.sprinklerAnalysis.filter(s => !s.adequate).length;
                if (inadequateSprinklers > 0) {
                    results.warnings.push(`${inadequateSprinklers} sprinklers may not provide adequate flow`);
                }

            } catch (error) {
                console.error('Error in hydraulics analysis:', error);
                results.errors.push('Error performing hydraulics analysis: ' + error.message);
            }

            state.hydraulics.calculated = true;
            state.hydraulics.results = results;
            return results;
        }

        /**
         * Run hydraulics analysis and display results
         */
        function runHydraulicsAnalysis() {
            try {
                // Update hydraulics parameters from UI
                state.hydraulics.pipeMaterial = document.getElementById('pipeMaterial').value;
                state.hydraulics.systemPressure = parseFloat(document.getElementById('systemPressure').value);
                state.hydraulics.designDensity = parseFloat(document.getElementById('designDensity').value);
                state.hydraulics.remoteArea = parseFloat(document.getElementById('remoteArea').value);
                state.hydraulics.elevationHead = parseFloat(document.getElementById('elevationHead').value);

                // Perform analysis
                const results = performHydraulicsAnalysis();
                
                // Show results button
                document.getElementById('showResultsBtn').style.display = 'inline-block';
                
                // Display summary in toast
                let message = `Hydraulics Analysis Complete!\n`;
                message += `System Flow: ${results.systemSummary.systemFlow} GPM\n`;
                message += `Pressure Loss: ${results.systemSummary.totalPressureLoss} PSI\n`;
                message += `Available Pressure: ${results.systemSummary.availablePressure} PSI\n`;
                
                if (results.warnings.length > 0) {
                    message += `\nWarnings: ${results.warnings.length}`;
                }
                if (results.errors.length > 0) {
                    message += `\nErrors: ${results.errors.length}`;
                }
                
                showToast(message, 8000); // Show for 8 seconds instead of default 2 seconds
                
            } catch (error) {
                console.error('Error running hydraulics analysis:', error);
                showToast('Error running hydraulics analysis: ' + error.message);
            }
        }

        /**
         * Show detailed hydraulics results in a modal
         */
        function showHydraulicsResults() {
            if (!state.hydraulics.calculated || !state.hydraulics.results) {
                showToast('No hydraulics results available. Run analysis first.');
                return;
            }

            const results = state.hydraulics.results;
            
            // Create modal HTML
            const modalHtml = `
                <div id="hydraulicsModal" style="
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                    background: rgba(0,0,0,0.8); z-index: 1000; display: flex; 
                    align-items: center; justify-content: center;
                ">
                    <div style="
                        background: #2c2c2c; color: #e0e0e0; padding: 20px; 
                        border-radius: 8px; max-width: 90%; max-height: 90%; 
                        overflow-y: auto; border: 1px solid #555;
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="margin: 0; color: #4CAF50;">Hydraulics Analysis Results</h2>
                            <button onclick="closeHydraulicsModal()" style="
                                background: #dc3545; color: white; border: none; 
                                padding: 5px 10px; border-radius: 4px; cursor: pointer;
                            ">Close</button>
                        </div>
                        
                        ${generateHydraulicsReportHTML(results)}
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        /**
         * Generate HTML for hydraulics report
         */
        function generateHydraulicsReportHTML(results) {
            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #4CAF50;">System Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">
                        <tr style="background: #333;">
                            <td style="padding: 8px; border: 1px solid #555;">Total Pipes</td>
                            <td style="padding: 8px; border: 1px solid #555;">${results.systemSummary.totalPipes}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Total Sprinklers</td>
                            <td style="padding: 8px; border: 1px solid #555;">${results.systemSummary.totalSprinklers}</td>
                        </tr>
                        <tr style="background: #333;">
                            <td style="padding: 8px; border: 1px solid #555;">Total Pipe Length (ft)</td>
                            <td style="padding: 8px; border: 1px solid #555;">${results.systemSummary.totalPipeLength}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">System Flow (GPM)</td>
                            <td style="padding: 8px; border: 1px solid #555;">${results.systemSummary.systemFlow}</td>
                        </tr>
                        <tr style="background: #333;">
                            <td style="padding: 8px; border: 1px solid #555;">Total Pressure Loss (PSI)</td>
                            <td style="padding: 8px; border: 1px solid #555;">${results.systemSummary.totalPressureLoss}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border: 1px solid #555;">Available Pressure (PSI)</td>
                            <td style="padding: 8px; border: 1px solid #555; color: ${results.systemSummary.systemAdequate ? '#4CAF50' : '#f44336'};">${results.systemSummary.availablePressure}</td>
                        </tr>
                        <tr style="background: #333;">
                            <td style="padding: 8px; border: 1px solid #555;">System Adequate</td>
                            <td style="padding: 8px; border: 1px solid #555; color: ${results.systemSummary.systemAdequate ? '#4CAF50' : '#f44336'};">
                                ${results.systemSummary.systemAdequate ? 'YES' : 'NO'}
                            </td>
                        </tr>
                    </table>
                </div>
            `;

            // Add system fittings summary
            if (state.hydraulics.systemFittings.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #4CAF50;">System Fittings</h3>
                        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                            <tr style="background: #333;">
                                <th style="padding: 6px; border: 1px solid #555;">Fitting Type</th>
                                <th style="padding: 6px; border: 1px solid #555;">Quantity</th>
                            </tr>
                `;
                
                state.hydraulics.systemFittings.forEach(fitting => {
                    html += `
                        <tr>
                            <td style="padding: 6px; border: 1px solid #555;">${getFittingDisplayName(fitting.type)}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${fitting.quantity}</td>
                        </tr>
                    `;
                });
                
                html += `</table></div>`;
            }

            // Add warnings and errors
            if (results.warnings.length > 0 || results.errors.length > 0) {
                html += `<div style="margin-bottom: 20px;">`;
                if (results.errors.length > 0) {
                    html += `<h3 style="color: #f44336;">Errors</h3><ul style="color: #f44336;">`;
                    results.errors.forEach(error => html += `<li>${error}</li>`);
                    html += `</ul>`;
                }
                if (results.warnings.length > 0) {
                    html += `<h3 style="color: #ff9800;">Warnings</h3><ul style="color: #ff9800;">`;
                    results.warnings.forEach(warning => html += `<li>${warning}</li>`);
                    html += `</ul>`;
                }
                html += `</div>`;
            }

            // Add pipe segments table
            if (results.pipeSegments.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #4CAF50;">Pipe Segments</h3>
                        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <tr style="background: #333;">
                            <th style="padding: 6px; border: 1px solid #555;">#</th>
                            <th style="padding: 6px; border: 1px solid #555;">Size</th>
                            <th style="padding: 6px; border: 1px solid #555;">Length (ft)</th>
                            <th style="padding: 6px; border: 1px solid #555;">Flow (GPM)</th>
                            <th style="padding: 6px; border: 1px solid #555;">Friction Loss (PSI)</th>
                            <th style="padding: 6px; border: 1px solid #555;">Fitting Loss (PSI)</th>
                            <th style="padding: 6px; border: 1px solid #555;">Total Loss (PSI)</th>
                        </tr>
                `;
                
                results.pipeSegments.forEach(segment => {
                    html += `
                        <tr>
                            <td style="padding: 6px; border: 1px solid #555;">${segment.index}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${segment.size}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${segment.length}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${segment.flow}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${(segment.pressureLoss - segment.fittingLoss).toFixed(2)}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${segment.fittingLoss}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${segment.pressureLoss}</td>
                        </tr>
                    `;
                });
                
                html += `</table></div>`;
            }

            // Add sprinkler analysis table
            if (results.sprinklerAnalysis.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: #4CAF50;">Sprinkler Analysis</h3>
                        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                            <tr style="background: #333;">
                                <th style="padding: 6px; border: 1px solid #555;">#</th>
                                <th style="padding: 6px; border: 1px solid #555;">Pressure (PSI)</th>
                                <th style="padding: 6px; border: 1px solid #555;">Actual Flow (GPM)</th>
                                <th style="padding: 6px; border: 1px solid #555;">Required Flow (GPM)</th>
                                <th style="padding: 6px; border: 1px solid #555;">Adequate</th>
                            </tr>
                `;
                
                results.sprinklerAnalysis.forEach(sprinkler => {
                    html += `
                        <tr>
                            <td style="padding: 6px; border: 1px solid #555;">${sprinkler.index}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${sprinkler.pressure}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${sprinkler.actualFlow}</td>
                            <td style="padding: 6px; border: 1px solid #555;">${sprinkler.requiredFlow}</td>
                            <td style="padding: 6px; border: 1px solid #555; color: ${sprinkler.adequate ? '#4CAF50' : '#f44336'};">
                                ${sprinkler.adequate ? 'YES' : 'NO'}
                            </td>
                        </tr>
                    `;
                });
                
                html += `</table></div>`;
            }

            return html;
        }

        /**
         * Close hydraulics results modal
         */
        function closeHydraulicsModal() {
            const modal = document.getElementById('hydraulicsModal');
            if (modal) {
                modal.remove();
            }
        }

        // ===== MATERIAL DATABASE & COSTING SYSTEM =====
        
        /**
         * Comprehensive material database for sprinkler systems
         */
        const materialDatabase = [
            // Sprinkler Heads
            { id: 'sprinkler_standard_1', name: 'Standard Sprinkler Head - 1/2"', category: 'sprinklers', partNumber: 'SS-1/2', price: 12.50, laborHours: 0.25, description: 'Standard response sprinkler head, 1/2" NPT' },
            { id: 'sprinkler_standard_3/4', name: 'Standard Sprinkler Head - 3/4"', category: 'sprinklers', partNumber: 'SS-3/4', price: 15.75, laborHours: 0.25, description: 'Standard response sprinkler head, 3/4" NPT' },
            { id: 'sprinkler_quick_1/2', name: 'Quick Response Sprinkler - 1/2"', category: 'sprinklers', partNumber: 'QR-1/2', price: 18.25, laborHours: 0.25, description: 'Quick response sprinkler head, 1/2" NPT' },
            { id: 'sprinkler_quick_3/4', name: 'Quick Response Sprinkler - 3/4"', category: 'sprinklers', partNumber: 'QR-3/4', price: 22.50, laborHours: 0.25, description: 'Quick response sprinkler head, 3/4" NPT' },
            { id: 'sprinkler_esfr', name: 'ESFR Sprinkler Head', category: 'sprinklers', partNumber: 'ESFR-1', price: 45.00, laborHours: 0.5, description: 'Early Suppression Fast Response sprinkler' },
            
            // Pipes & Fittings
            { id: 'pipe_steel_1/2', name: 'Steel Pipe - 1/2" x 20ft', category: 'pipes', partNumber: 'SP-1/2-20', price: 8.50, laborHours: 0.1, description: 'Schedule 40 steel pipe, 1/2" diameter, 20ft length' },
            { id: 'pipe_steel_3/4', name: 'Steel Pipe - 3/4" x 20ft', category: 'pipes', partNumber: 'SP-3/4-20', price: 12.25, laborHours: 0.1, description: 'Schedule 40 steel pipe, 3/4" diameter, 20ft length' },
            { id: 'pipe_steel_1', name: 'Steel Pipe - 1" x 20ft', category: 'pipes', partNumber: 'SP-1-20', price: 18.75, laborHours: 0.15, description: 'Schedule 40 steel pipe, 1" diameter, 20ft length' },
            { id: 'pipe_steel_1-1/4', name: 'Steel Pipe - 1-1/4" x 20ft', category: 'pipes', partNumber: 'SP-1-1/4-20', price: 28.50, laborHours: 0.2, description: 'Schedule 40 steel pipe, 1-1/4" diameter, 20ft length' },
            { id: 'pipe_steel_1-1/2', name: 'Steel Pipe - 1-1/2" x 20ft', category: 'pipes', partNumber: 'SP-1-1/2-20', price: 35.25, laborHours: 0.25, description: 'Schedule 40 steel pipe, 1-1/2" diameter, 20ft length' },
            { id: 'pipe_steel_2', name: 'Steel Pipe - 2" x 20ft', category: 'pipes', partNumber: 'SP-2-20', price: 52.00, laborHours: 0.3, description: 'Schedule 40 steel pipe, 2" diameter, 20ft length' },
            
            // Fittings
            { id: 'elbow_90_1/2', name: '90 Elbow - 1/2"', category: 'pipes', partNumber: 'EL-90-1/2', price: 3.25, laborHours: 0.1, description: '90 degree elbow fitting, 1/2" NPT' },
            { id: 'elbow_90_3/4', name: '90 Elbow - 3/4"', category: 'pipes', partNumber: 'EL-90-3/4', price: 4.50, laborHours: 0.1, description: '90 degree elbow fitting, 3/4" NPT' },
            { id: 'elbow_90_1', name: '90 Elbow - 1"', category: 'pipes', partNumber: 'EL-90-1', price: 6.75, laborHours: 0.15, description: '90 degree elbow fitting, 1" NPT' },
            { id: 'tee_1/2', name: 'Tee Fitting - 1/2"', category: 'pipes', partNumber: 'TEE-1/2', price: 4.25, laborHours: 0.15, description: 'Tee fitting, 1/2" NPT' },
            { id: 'tee_3/4', name: 'Tee Fitting - 3/4"', category: 'pipes', partNumber: 'TEE-3/4', price: 6.50, laborHours: 0.15, description: 'Tee fitting, 3/4" NPT' },
            { id: 'tee_1', name: 'Tee Fitting - 1"', category: 'pipes', partNumber: 'TEE-1', price: 9.75, laborHours: 0.2, description: 'Tee fitting, 1" NPT' },
            
            // Valves
            { id: 'valve_gate_1/2', name: 'Gate Valve - 1/2"', category: 'valves', partNumber: 'GV-1/2', price: 15.50, laborHours: 0.5, description: 'Gate valve, 1/2" NPT' },
            { id: 'valve_gate_3/4', name: 'Gate Valve - 3/4"', category: 'valves', partNumber: 'GV-3/4', price: 22.75, laborHours: 0.5, description: 'Gate valve, 3/4" NPT' },
            { id: 'valve_gate_1', name: 'Gate Valve - 1"', category: 'valves', partNumber: 'GV-1', price: 35.25, laborHours: 0.75, description: 'Gate valve, 1" NPT' },
            { id: 'valve_check_1/2', name: 'Check Valve - 1/2"', category: 'valves', partNumber: 'CV-1/2', price: 18.50, laborHours: 0.5, description: 'Check valve, 1/2" NPT' },
            { id: 'valve_check_3/4', name: 'Check Valve - 3/4"', category: 'valves', partNumber: 'CV-3/4', price: 28.75, laborHours: 0.5, description: 'Check valve, 3/4" NPT' },
            { id: 'valve_check_1', name: 'Check Valve - 1"', category: 'valves', partNumber: 'CV-1', price: 42.50, laborHours: 0.75, description: 'Check valve, 1" NPT' },
            { id: 'valve_butterfly_2', name: 'Butterfly Valve - 2"', category: 'valves', partNumber: 'BV-2', price: 125.00, laborHours: 1.0, description: 'Butterfly valve, 2" flanged' },
            { id: 'valve_butterfly_3', name: 'Butterfly Valve - 3"', category: 'valves', partNumber: 'BV-3', price: 185.00, laborHours: 1.25, description: 'Butterfly valve, 3" flanged' },
            
            // Hangers & Supports
            { id: 'hanger_1/2', name: 'Pipe Hanger - 1/2"', category: 'hangers', partNumber: 'H-1/2', price: 2.50, laborHours: 0.1, description: 'Pipe hanger for 1/2" pipe' },
            { id: 'hanger_3/4', name: 'Pipe Hanger - 3/4"', category: 'hangers', partNumber: 'H-3/4', price: 3.25, laborHours: 0.1, description: 'Pipe hanger for 3/4" pipe' },
            { id: 'hanger_1', name: 'Pipe Hanger - 1"', category: 'hangers', partNumber: 'H-1', price: 4.50, laborHours: 0.15, description: 'Pipe hanger for 1" pipe' },
            { id: 'hanger_1-1/4', name: 'Pipe Hanger - 1-1/4"', category: 'hangers', partNumber: 'H-1-1/4', price: 6.75, laborHours: 0.15, description: 'Pipe hanger for 1-1/4" pipe' },
            { id: 'hanger_1-1/2', name: 'Pipe Hanger - 1-1/2"', category: 'hangers', partNumber: 'H-1-1/2', price: 8.25, laborHours: 0.2, description: 'Pipe hanger for 1-1/2" pipe' },
            { id: 'hanger_2', name: 'Pipe Hanger - 2"', category: 'hangers', partNumber: 'H-2', price: 12.50, laborHours: 0.25, description: 'Pipe hanger for 2" pipe' },
            { id: 'hanger_rod_1/4', name: 'Hanger Rod - 1/4" x 6ft', category: 'hangers', partNumber: 'HR-1/4-6', price: 1.25, laborHours: 0.05, description: 'Threaded rod for pipe hangers' },
            { id: 'hanger_rod_3/8', name: 'Hanger Rod - 3/8" x 6ft', category: 'hangers', partNumber: 'HR-3/8-6', price: 1.75, laborHours: 0.05, description: 'Threaded rod for pipe hangers' },
            
            // Accessories
            { id: 'fitting_reducer_1-3/4', name: 'Reducer - 1" to 3/4"', category: 'accessories', partNumber: 'RED-1-3/4', price: 5.25, laborHours: 0.1, description: 'Pipe reducer fitting' },
            { id: 'fitting_reducer_3/4-1/2', name: 'Reducer - 3/4" to 1/2"', category: 'accessories', partNumber: 'RED-3/4-1/2', price: 4.50, laborHours: 0.1, description: 'Pipe reducer fitting' },
            { id: 'fitting_coupling_1/2', name: 'Coupling - 1/2"', category: 'accessories', partNumber: 'CPL-1/2', price: 2.25, laborHours: 0.05, description: 'Pipe coupling, 1/2" NPT' },
            { id: 'fitting_coupling_3/4', name: 'Coupling - 3/4"', category: 'accessories', partNumber: 'CPL-3/4', price: 3.50, laborHours: 0.05, description: 'Pipe coupling, 3/4" NPT' },
            { id: 'fitting_coupling_1', name: 'Coupling - 1"', category: 'accessories', partNumber: 'CPL-1', price: 5.25, laborHours: 0.1, description: 'Pipe coupling, 1" NPT' },
            { id: 'fitting_union_1/2', name: 'Union - 1/2"', category: 'accessories', partNumber: 'UN-1/2', price: 8.50, laborHours: 0.15, description: 'Pipe union, 1/2" NPT' },
            { id: 'fitting_union_3/4', name: 'Union - 3/4"', category: 'accessories', partNumber: 'UN-3/4', price: 12.75, laborHours: 0.15, description: 'Pipe union, 3/4" NPT' },
            { id: 'fitting_union_1', name: 'Union - 1"', category: 'accessories', partNumber: 'UN-1', price: 18.25, laborHours: 0.2, description: 'Pipe union, 1" NPT' },
            { id: 'fitting_plug_1/2', name: 'Pipe Plug - 1/2"', category: 'accessories', partNumber: 'PLUG-1/2', price: 1.50, laborHours: 0.05, description: 'Pipe plug, 1/2" NPT' },
            { id: 'fitting_plug_3/4', name: 'Pipe Plug - 3/4"', category: 'accessories', partNumber: 'PLUG-3/4', price: 2.25, laborHours: 0.05, description: 'Pipe plug, 3/4" NPT' },
            { id: 'fitting_plug_1', name: 'Pipe Plug - 1"', category: 'accessories', partNumber: 'PLUG-1', price: 3.50, laborHours: 0.1, description: 'Pipe plug, 1" NPT' }
        ];

        /**
         * Initialize material database
         */
        function initializeMaterialDatabase() {
            state.materials.materialDatabase = materialDatabase;
            populateMaterialList();
        }

        /**
         * Toggle material panel visibility
         */
        function toggleMaterialPanel() {
            const panel = document.getElementById('materialPanel');
            const arrow = document.getElementById('materialArrow');
            
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                arrow.style.transform = 'rotate(180deg)';
                if (state.materials.materialDatabase.length === 0) {
                    initializeMaterialDatabase();
                }
            } else {
                panel.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            }
        }

        /**
         * Populate material list based on current filters
         */
        function populateMaterialList() {
            const materialList = document.getElementById('materialList');
            const searchTerm = state.materials.searchTerm.toLowerCase();
            const category = state.materials.selectedCategory;
            
            let filteredMaterials = state.materials.materialDatabase.filter(material => {
                const matchesSearch = material.name.toLowerCase().includes(searchTerm) ||
                                    material.partNumber.toLowerCase().includes(searchTerm) ||
                                    material.description.toLowerCase().includes(searchTerm);
                const matchesCategory = category === 'all' || material.category === category;
                return matchesSearch && matchesCategory;
            });
            
            materialList.innerHTML = '';
            
            if (filteredMaterials.length === 0) {
                materialList.innerHTML = '<div style="padding: 10px; text-align: center; color: #aaa;">No materials found</div>';
                return;
            }
            
            filteredMaterials.forEach(material => {
                const materialItem = document.createElement('div');
                materialItem.className = 'material-item';
                materialItem.innerHTML = `
                    <div class="material-info">
                        <div class="material-name">${material.name}</div>
                        <div class="material-details">${material.partNumber} - ${material.description}</div>
                    </div>
                    <div class="material-price">$${material.price.toFixed(2)}</div>
                    <button class="add-material-btn" onclick="addMaterialToProject('${material.id}')">Add</button>
                `;
                materialList.appendChild(materialItem);
            });
        }

        /**
         * Add material to project
         */
        function addMaterialToProject(materialId) {
            const material = state.materials.materialDatabase.find(m => m.id === materialId);
            if (!material) return;
            
            // Check if material already exists in project
            const existingMaterial = state.materials.projectMaterials.find(m => m.id === materialId);
            if (existingMaterial) {
                existingMaterial.quantity += 1;
            } else {
                state.materials.projectMaterials.push({
                    ...material,
                    quantity: 1
                });
            }
            
            updateProjectMaterialsList();
            updateMaterialSummary();
            showToast(`${material.name} added to project`);
        }

        /**
         * Remove material from project
         */
        function removeMaterialFromProject(materialId) {
            state.materials.projectMaterials = state.materials.projectMaterials.filter(m => m.id !== materialId);
            updateProjectMaterialsList();
            updateMaterialSummary();
        }

        /**
         * Update material quantity in project
         */
        function updateMaterialQuantity(materialId, newQuantity) {
            const material = state.materials.projectMaterials.find(m => m.id === materialId);
            if (material) {
                if (newQuantity <= 0) {
                    removeMaterialFromProject(materialId);
                } else {
                    material.quantity = parseInt(newQuantity);
                    updateProjectMaterialsList();
                    updateMaterialSummary();
                }
            }
        }

        /**
         * Update project materials list display
         */
        function updateProjectMaterialsList() {
            const projectMaterialsList = document.getElementById('projectMaterialsList');
            projectMaterialsList.innerHTML = '';
            
            if (state.materials.projectMaterials.length === 0) {
                projectMaterialsList.innerHTML = '<div style="padding: 10px; text-align: center; color: #aaa;">No materials added</div>';
                return;
            }
            
            state.materials.projectMaterials.forEach(material => {
                const materialItem = document.createElement('div');
                materialItem.className = 'project-material-item';
                materialItem.innerHTML = `
                    <div class="project-material-info">
                        <div class="material-name">${material.name}</div>
                        <div class="material-details">${material.partNumber}</div>
                    </div>
                    <div class="project-material-quantity">
                        <button onclick="updateMaterialQuantity('${material.id}', ${material.quantity - 1})">-</button>
                        <input type="number" value="${material.quantity}" min="1" 
                               onchange="updateMaterialQuantity('${material.id}', this.value)">
                        <button onclick="updateMaterialQuantity('${material.id}', ${material.quantity + 1})">+</button>
                    </div>
                    <div class="material-price">$${(material.price * material.quantity).toFixed(2)}</div>
                    <button class="remove-material-btn" onclick="removeMaterialFromProject('${material.id}')"></button>
                `;
                projectMaterialsList.appendChild(materialItem);
            });
        }

        /**
         * Update material summary
         */
        function updateMaterialSummary() {
            const totalItems = state.materials.projectMaterials.reduce((sum, material) => sum + material.quantity, 0);
            const totalCost = state.materials.projectMaterials.reduce((sum, material) => sum + (material.price * material.quantity), 0);
            const totalLaborHours = state.materials.projectMaterials.reduce((sum, material) => sum + (material.laborHours * material.quantity), 0);
            
            document.getElementById('totalItems').textContent = totalItems;
            document.getElementById('totalCost').textContent = `$${totalCost.toFixed(2)}`;
            document.getElementById('totalLaborHours').textContent = totalLaborHours.toFixed(1);
        }

        /**
         * Search materials
         */
        function searchMaterials() {
            const searchInput = document.getElementById('materialSearch');
            state.materials.searchTerm = searchInput.value;
            populateMaterialList();
        }

        /**
         * Filter materials by category
         */
        function filterMaterialsByCategory() {
            const categorySelect = document.getElementById('materialCategory');
            state.materials.selectedCategory = categorySelect.value;
            populateMaterialList();
        }

        /**
         * Generate material list report
         */
        function generateMaterialList() {
            if (state.materials.projectMaterials.length === 0) {
                showToast('No materials in project to generate list');
                return;
            }
            
            const reportWindow = window.open('', '_blank');
            if (!reportWindow) {
                showToast('Please allow popups to generate material list');
                return;
            }
            
            let reportHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Material List - ${new Date().toLocaleDateString()}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                        th { background-color: #f2f2f2; }
                        .summary { background-color: #f9f9f9; padding: 15px; border-radius: 5px; }
                        .header { text-align: center; margin-bottom: 30px; }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>Fire Sprinkler System - Material List</h1>
                        <p>Generated: ${new Date().toLocaleString()}</p>
                    </div>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Part Number</th>
                                <th>Description</th>
                                <th>Quantity</th>
                                <th>Unit Price</th>
                                <th>Total Price</th>
                                <th>Labor Hours</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            state.materials.projectMaterials.forEach(material => {
                reportHTML += `
                    <tr>
                        <td>${material.partNumber}</td>
                        <td>${material.name}</td>
                        <td>${material.quantity}</td>
                        <td>$${material.price.toFixed(2)}</td>
                        <td>$${(material.price * material.quantity).toFixed(2)}</td>
                        <td>${(material.laborHours * material.quantity).toFixed(1)}</td>
                    </tr>
                `;
            });
            
            const totalCost = state.materials.projectMaterials.reduce((sum, material) => sum + (material.price * material.quantity), 0);
            const totalLaborHours = state.materials.projectMaterials.reduce((sum, material) => sum + (material.laborHours * material.quantity), 0);
            const totalItems = state.materials.projectMaterials.reduce((sum, material) => sum + material.quantity, 0);
            
            reportHTML += `
                        </tbody>
                    </table>
                    
                    <div class="summary">
                        <h3>Project Summary</h3>
                        <p><strong>Total Items:</strong> ${totalItems}</p>
                        <p><strong>Total Material Cost:</strong> $${totalCost.toFixed(2)}</p>
                        <p><strong>Total Labor Hours:</strong> ${totalLaborHours.toFixed(1)} hours</p>
                        <p><strong>Estimated Labor Cost:</strong> $${(totalLaborHours * 75).toFixed(2)} (at $75/hour)</p>
                        <p><strong>Total Project Cost:</strong> $${(totalCost + (totalLaborHours * 75)).toFixed(2)}</p>
                    </div>
                </body>
                </html>
            `;
            
            reportWindow.document.write(reportHTML);
            reportWindow.document.close();
            showToast('Material list generated in new tab');
        }

        /**
         * Export material list to Excel (CSV format)
         */
        function exportMaterialList() {
            if (state.materials.projectMaterials.length === 0) {
                showToast('No materials in project to export');
                return;
            }
            
            let csvContent = "Part Number,Description,Quantity,Unit Price,Total Price,Labor Hours\n";
            
            state.materials.projectMaterials.forEach(material => {
                csvContent += `${material.partNumber},"${material.name}",${material.quantity},${material.price.toFixed(2)},${(material.price * material.quantity).toFixed(2)},${(material.laborHours * material.quantity).toFixed(1)}\n`;
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `material-list-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Material list exported to CSV');
        }

        /**
         * Clear all project materials
         */
        function clearProjectMaterials() {
            if (state.materials.projectMaterials.length === 0) {
                showToast('No materials to clear');
                return;
            }
            
            if (confirm('Are you sure you want to clear all project materials?')) {
                state.materials.projectMaterials = [];
                updateProjectMaterialsList();
                updateMaterialSummary();
                showToast('All project materials cleared');
            }
        }

        /**
         * Toggle hydraulics panel visibility
         */
        function toggleHydraulicsPanel() {
            const panel = document.getElementById('hydraulicsPanel');
            const arrow = document.getElementById('hydraulicsArrow');
            
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                arrow.classList.add('rotated');
            } else {
                panel.style.display = 'none';
                arrow.classList.remove('rotated');
            }
        }

        /**
         * Open the All Lists Modal and populate it with all items
         */
        function openAllListsModal() {
            const modal = document.getElementById('allListsModal');
            const modalBody = document.getElementById('allListsModalBody');
            
            if (!modal || !modalBody) return;
            
            // Collect all items from all layers
            const allItems = {
                pipes: [],
                sprinklers: [],
                extinguishers: [],
                valves: [],
                pullStations: [],
                flowSwitches: [],
                pressureGauges: [],
                rooms: [],
                doors: [],
                windows: [],
                texts: [],
                dimensions: []
            };
            
            state.layers.forEach(layer => {
                layer.items.forEach(item => {
                    if (item.type && allItems[item.type + 's']) {
                        allItems[item.type + 's'].push(item);
                    } else if (item.type === 'pipe') {
                        allItems.pipes.push(item);
                    } else if (item.type === 'text') {
                        allItems.texts.push(item);
                    } else if (item.type === 'room') {
                        allItems.rooms.push(item);
                    } else if (item.type === 'door') {
                        allItems.doors.push(item);
                    } else if (item.type === 'window') {
                        allItems.windows.push(item);
                    } else if (item.type === 'dimension') {
                        allItems.dimensions.push(item);
                    }
                });
            });
            
            // Generate HTML for the modal
            let html = '';
            
            // Helper function to format coordinates
            const formatCoords = (item) => {
                if (item.x !== undefined && item.y !== undefined) {
                    const gridX = Math.round(item.x / gridSize);
                    const gridYLabel = getColumnLabel(Math.round(item.y / gridSize) - 1);
                    return `(${gridX}, ${gridYLabel})`;
                }
                return 'N/A';
            };
            
            // Pipes Section
            if (allItems.pipes.length > 0) {
                html += '<div class="lists-modal-section"><h3>Pipes (' + allItems.pipes.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Size</th><th>Length (ft)</th><th>From</th><th>To</th><th>Name</th></tr></thead><tbody>';
                allItems.pipes.forEach((pipe, index) => {
                    const length = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                    const lengthFeet = (length / gridSize).toFixed(1);
                    const fromCoords = `(${Math.round(pipe.x1 / gridSize)}, ${getColumnLabel(Math.round(pipe.y1 / gridSize) - 1)})`;
                    const toCoords = `(${Math.round(pipe.x2 / gridSize)}, ${getColumnLabel(Math.round(pipe.y2 / gridSize) - 1)})`;
                    html += `<tr><td>${index + 1}</td><td>${pipe.size || 'N/A'}</td><td>${lengthFeet}</td><td>${fromCoords}</td><td>${toCoords}</td><td>${pipe.name || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Sprinklers Section
            if (allItems.sprinklers.length > 0) {
                html += '<div class="lists-modal-section"><h3>Sprinklers (' + allItems.sprinklers.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th></tr></thead><tbody>';
                allItems.sprinklers.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${item.name || ''}</td><td>${formatCoords(item)}</td><td>${item.notes || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Extinguishers Section
            if (allItems.extinguishers.length > 0) {
                html += '<div class="lists-modal-section"><h3>Fire Extinguishers (' + allItems.extinguishers.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th></tr></thead><tbody>';
                allItems.extinguishers.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${item.name || ''}</td><td>${formatCoords(item)}</td><td>${item.notes || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Valves Section
            if (allItems.valves.length > 0) {
                html += '<div class="lists-modal-section"><h3>Valves (' + allItems.valves.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th></tr></thead><tbody>';
                allItems.valves.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${item.name || ''}</td><td>${formatCoords(item)}</td><td>${item.notes || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Pull Stations Section
            if (allItems.pullStations.length > 0) {
                html += '<div class="lists-modal-section"><h3>Pull Stations (' + allItems.pullStations.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th></tr></thead><tbody>';
                allItems.pullStations.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${item.name || ''}</td><td>${formatCoords(item)}</td><td>${item.notes || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Flow Switches Section
            if (allItems.flowSwitches.length > 0) {
                html += '<div class="lists-modal-section"><h3>Flow Switches (' + allItems.flowSwitches.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th></tr></thead><tbody>';
                allItems.flowSwitches.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${item.name || ''}</td><td>${formatCoords(item)}</td><td>${item.notes || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Pressure Gauges Section
            if (allItems.pressureGauges.length > 0) {
                html += '<div class="lists-modal-section"><h3>Pressure Gauges (' + allItems.pressureGauges.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Location</th><th>Notes</th></tr></thead><tbody>';
                allItems.pressureGauges.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${item.name || ''}</td><td>${formatCoords(item)}</td><td>${item.notes || ''}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Rooms Section
            if (allItems.rooms.length > 0) {
                html += '<div class="lists-modal-section"><h3>Rooms (' + allItems.rooms.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Name</th><th>Perimeter (ft)</th></tr></thead><tbody>';
                allItems.rooms.forEach((room, index) => {
                    const perimeter = calculateRoomPerimeter(room);
                    const perimeterFeet = (perimeter / gridSize).toFixed(1);
                    html += `<tr><td>${index + 1}</td><td>${room.name || 'Unnamed Room'}</td><td>${perimeterFeet}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Doors Section
            if (allItems.doors.length > 0) {
                html += '<div class="lists-modal-section"><h3>Doors (' + allItems.doors.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Location</th><th>Width (ft)</th></tr></thead><tbody>';
                allItems.doors.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${formatCoords(item)}</td><td>${item.width || 'N/A'}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            // Windows Section
            if (allItems.windows.length > 0) {
                html += '<div class="lists-modal-section"><h3>Windows (' + allItems.windows.length + ')</h3>';
                html += '<table class="lists-modal-table"><thead><tr><th>ID</th><th>Location</th><th>Width (ft)</th></tr></thead><tbody>';
                allItems.windows.forEach((item, index) => {
                    html += `<tr><td>${index + 1}</td><td>${formatCoords(item)}</td><td>${item.width || 'N/A'}</td></tr>`;
                });
                html += '</tbody></table></div>';
            }
            
            if (html === '') {
                html = '<div class="lists-modal-section"><p style="color: var(--off-white); text-align: center; padding: 20px;">No items to display yet. Start adding items to your design!</p></div>';
            }
            
            modalBody.innerHTML = html;
            modal.classList.add('active');
            
            // Close modal on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeAllListsModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        /**
         * Close the All Lists Modal
         */
        function closeAllListsModal() {
            const modal = document.getElementById('allListsModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Handle clicks on the modal backdrop to close it
         */
        function handleListsModalClick(event) {
            if (event.target.id === 'allListsModal') {
                closeAllListsModal();
            }
        }

        /**
         * Add fitting to system
         */
        function addFittingToSystem() {
            const fittingType = document.getElementById('fittingType').value;
            const quantity = parseInt(document.getElementById('fittingQuantity').value);
            
            if (!fittingType || quantity <= 0) {
                showToast('Please select a fitting type and quantity');
                return;
            }
            
            // Check if fitting already exists
            const existingFitting = state.hydraulics.systemFittings.find(f => f.type === fittingType);
            if (existingFitting) {
                existingFitting.quantity += quantity;
            } else {
                state.hydraulics.systemFittings.push({
                    type: fittingType,
                    quantity: quantity
                });
            }
            
            updateFittingsList();
            showToast(`Added ${quantity} ${getFittingDisplayName(fittingType)}${quantity > 1 ? 's' : ''}`);
        }

        /**
         * Remove fitting from system
         */
        function removeFittingFromSystem(index) {
            state.hydraulics.systemFittings.splice(index, 1);
            updateFittingsList();
            showToast('Fitting removed');
        }

        /**
         * Update fittings list display
         */
        function updateFittingsList() {
            const fittingsList = document.getElementById('fittingsList');
            fittingsList.innerHTML = '';
            
            if (state.hydraulics.systemFittings.length === 0) {
                fittingsList.innerHTML = '<div style="color: #666; font-style: italic;">No fittings added</div>';
                return;
            }
            
            state.hydraulics.systemFittings.forEach((fitting, index) => {
                const fittingItem = document.createElement('div');
                fittingItem.className = 'fitting-item';
                fittingItem.innerHTML = `
                    <span>${fitting.quantity}x ${getFittingDisplayName(fitting.type)}</span>
                    <button onclick="removeFittingFromSystem(${index})">Remove</button>
                `;
                fittingsList.appendChild(fittingItem);
            });
        }

        /**
         * Get display name for fitting type
         */
        function getFittingDisplayName(fittingType) {
            const displayNames = {
                '90_elbow': '90 Elbow',
                '45_elbow': '45 Elbow',
                'tee_straight': 'Tee (Straight)',
                'tee_branch': 'Tee (Branch)',
                'gate_valve_open': 'Gate Valve',
                'check_valve': 'Check Valve',
                'butterfly_valve': 'Butterfly Valve',
                'reducer': 'Reducer'
            };
            return displayNames[fittingType] || fittingType;
        }

        /**
         * Calculates angle between two points and checks if it's near a 45-degree increment.
         * @returns {{angle: number, isStandard: boolean}} Angle in degrees (0-360) and standard status.
         */
        function getAngleStatus(x1, y1, x2, y2) {
            const deltaX = x2 - x1;
            const deltaY = y2 - y1;

            if (deltaX === 0 && deltaY === 0) return { angle: 0, isStandard: true };

            let angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            if (angle < 0) angle += 360; 

            const standardAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];
            const tolerance = 2.5; 
            
            let isStandard = standardAngles.some(stdAngle => Math.abs(angle - stdAngle) <= tolerance);
             if (!isStandard && (angle <= tolerance || angle >= (360 - tolerance))) isStandard = true;

            return { angle: angle, isStandard: isStandard };
        }

        /**
         * Find the nearest item of a specific type within a tolerance.
         * @param {number} x - X coordinate
         * @param {number} y - Y coordinate
         * @param {string} itemType - The type of item to search for (e.g., 'sprinkler')
         * @param {number} tolerance - Max distance in pixels to consider 'near'
         * @returns {object|null} The nearest item found, or null
         */
        function findNearestItem(x, y, itemType, tolerance) {
            let itemsToCheck = [];
            switch(itemType) {
                case 'sprinkler': itemsToCheck = state.sprinklers; break;
                case 'extinguisher': itemsToCheck = state.extinguishers; break;
                case 'valve': itemsToCheck = state.valves; break;
                case 'pullStation': itemsToCheck = state.pullStations; break;
                case 'flowSwitch': itemsToCheck = state.flowSwitches; break;
                case 'pressureGauge': itemsToCheck = state.pressureGauges; break;
                default: return null; // Unknown type
            }

            let nearest = null;
            let minDistSq = tolerance * tolerance; // Use squared distance for efficiency

            for (const item of itemsToCheck) {
                const dx = x - item.x;
                const dy = y - item.y;
                const distSq = dx * dx + dy * dy;

                if (distSq <= minDistSq) {
                    minDistSq = distSq;
                    nearest = item;
                    // Optimization: If we found a perfect match or very close, stop early
                    if (minDistSq < 1) break; 
                }
            }
            return nearest;
        }

        /**
         * Generates a unique ID for new layers.
         * @returns {string} A unique identifier.
         */
        function generateLayerId() {
            return `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        /**
         * Find the nearest text annotation within a tolerance.
         * Similar to findNearestItem but for the texts array.
         */
        function findNearestText(x, y, tolerance) {
            let nearest = null;
            let minDistSq = tolerance * tolerance;

            // Search through all layers
            for (const layer of state.layers) {
                if (!layer.visible) continue;
                for (const item of layer.items) {
                    if (item.type === 'text') {
                        const dx = x - item.x;
                        const dy = y - item.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq <= minDistSq) {
                            minDistSq = distSq;
                            nearest = item;
                            if (minDistSq < 1) break; // Optimization
                        }
                    }
                }
            }
            return nearest;
        }

        /**
         * Get the currently active layer object from state.
         * @returns {object|null} The active layer object or null if not found.
         */
        function getActiveLayer() {
            if (!state.activeLayerId) return null;
            return state.layers.find(layer => layer.id === state.activeLayerId);
        }
        
        /**
         * Adds a new layer to the state and updates the UI.
         */
        function addNewLayer() {
            const newLayerId = generateLayerId();
            const newLayer = {
                id: newLayerId,
                name: `Layer ${state.layers.length + 1}`,
                visible: true,
                locked: false,
                items: []
            };
            state.layers.push(newLayer);
            setActiveLayer(newLayerId); // New layer becomes active
            updateLayerList();
            saveState();
        }

        /**
         * Sets the active layer.
         * @param {string} layerId The ID of the layer to make active.
         */
        function setActiveLayer(layerId) {
            state.activeLayerId = layerId;
            updateLayerList();
            showToast(`Layer "${state.layers.find(l => l.id === layerId).name}" is now active.`);
        }

        /**
         * Toggles the visibility of a layer.
         * @param {string} layerId The ID of the layer to toggle.
         */
        function toggleLayerVisibility(layerId) {
            const layer = state.layers.find(l => l.id === layerId);
            if (layer) {
                layer.visible = !layer.visible;
                updateLayerList();
                redrawAll();
                saveState();
            }
        }

        /**
         * Toggles the locked state of a layer.
         * @param {string} layerId The ID of the layer to toggle.
         */
        function toggleLayerLock(layerId) {
            const layer = state.layers.find(l => l.id === layerId);
            if (layer) {
                layer.locked = !layer.locked;
                updateLayerList();
                saveState();
            }
        }

        /**
         * Renames a layer.
         * @param {string} layerId The ID of the layer to rename.
         */
        function renameLayer(layerId) {
            const layer = state.layers.find(l => l.id === layerId);
            if (layer) {
                const newName = prompt(`Enter new name for "${layer.name}":`, layer.name);
                if (newName && newName.trim() !== '' && newName !== layer.name) {
                    layer.name = newName.trim();
                    updateLayerList();
                    saveState();
                    showToast(`Layer renamed to "${newName}"`);
                }
            }
        }

        /**
         * Deletes a layer.
         * @param {string} layerId The ID of the layer to delete.
         */
        function deleteLayer(layerId) {
            if (state.layers.length <= 1) {
                showToast("Cannot delete the last layer.");
                return;
            }
            const layerIndex = state.layers.findIndex(l => l.id === layerId);
            if (layerIndex > -1) {
                const layerName = state.layers[layerIndex].name;
                if (confirm(`Are you sure you want to delete "${layerName}"?`)) {
                    state.layers.splice(layerIndex, 1);
                    if (state.activeLayerId === layerId) {
                        state.activeLayerId = state.layers[0]?.id || null;
                    }
                    updateLayerList();
                    redrawAll();
                    saveState();
                }
            }
        }

        /**
         * Renders the layer list in the sidebar.
         */
        function updateLayerList() {
            const layerList = elements.layerList;
            layerList.innerHTML = '';
            state.layers.forEach(layer => {
                const li = document.createElement('li');
                li.className = `layer-item ${layer.id === state.activeLayerId ? 'active' : ''}`;
                li.dataset.layerId = layer.id;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name';
                nameSpan.textContent = layer.name;
                nameSpan.onclick = () => setActiveLayer(layer.id);
                nameSpan.ondblclick = () => renameLayer(layer.id);
                nameSpan.title = 'Click to select, double-click to rename';

                const visibilityBtn = document.createElement('button');
                visibilityBtn.textContent = layer.visible ? '' : '';
                visibilityBtn.onclick = () => toggleLayerVisibility(layer.id);

                const lockBtn = document.createElement('button');
                lockBtn.textContent = layer.locked ? '' : '';
                lockBtn.className = layer.locked ? 'locked' : '';
                lockBtn.onclick = () => toggleLayerLock(layer.id);

                const renameBtn = document.createElement('button');
                renameBtn.textContent = '';
                renameBtn.title = 'Rename layer';
                renameBtn.onclick = () => renameLayer(layer.id);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '';
                deleteBtn.onclick = () => deleteLayer(layer.id);

                li.appendChild(visibilityBtn);
                li.appendChild(lockBtn);
                li.appendChild(nameSpan);
                li.appendChild(renameBtn);
                li.appendChild(deleteBtn);
                layerList.appendChild(li);
            });
        }


        // ===== DRAWING FUNCTIONS =====
        
        /**
         * Draw the grid
         */
        function drawGrid() {
            console.log('[DRAWGRID] Called.');
            try {
                // Check visibility flag
                if (!state.visibility.grid) {
                    // If grid is not visible, we still need to ensure the main drawing area is clear
                    // (in case background is also not visible or doesn't cover everything).
                    // This assumes redrawAll has already translated the context.
                    const ctx = elements.ctx;
                    ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                    return; 
                }
                
                const ctx = elements.ctx;
                const width = elements.canvas.width;
                const height = elements.canvas.height;
                const gridSize = parseInt(elements.gridSizeInput.value);
                
                // The main context is already translated by redrawAll.
                // Clear only the grid's drawing area.
                ctx.clearRect(0, 0, width, height);
                
                // Draw the grid
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; // Lighter grid on dark background
                ctx.lineWidth = 0.5;
                
                // Draw vertical grid lines
                for (let x = 0; x <= width; x += gridSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    
                    // Add column labels at the top
                    if (x > 0) {
                        const label = Math.floor(x / gridSize);
                        ctx.save();
                        ctx.fillStyle = '#888'; // Light grey labels
                        ctx.font = '10px Arial'; // Smaller font size
                        ctx.textAlign = 'center';
                        ctx.fillText(label.toString(), x, -25); // Moved above the grid
                        ctx.restore();
                    }
                }
                
                // Draw horizontal grid lines
                for (let y = 0; y <= height; y += gridSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    
                    // Add row labels on the left
                    if (y > 0) {
                        const label = getColumnLabel(Math.floor(y / gridSize) - 1);
                        ctx.save();
                        ctx.fillStyle = '#888'; // Light grey labels
                        ctx.font = '10px Arial'; // Smaller font size
                        ctx.textAlign = 'right';
                        ctx.fillText(label, -25, y + 3); // Moved to the left of the grid
                        ctx.restore();
                    }
                }
                
                ctx.stroke();
                
                // ctx.restore(); // No longer needed here as we don't ctx.save() or setTransform locally
            } catch (error) {
                console.error('Error drawing grid:', error);
                showToast('Error drawing grid');
            }
        }

        /**
         * Draw a single pipe
         * @param {object} pipe The pipe object to draw.
         */
        function drawPipe(pipe) {
            try {
                console.log('drawPipe called with:', pipe);
                const ctx = elements.ctx;
                if (!ctx) {
                    console.error('Canvas context not found');
                    return;
                }
                const gridSize = parseInt(elements.gridSizeInput.value);
                
                let exceedsMaxSpan = false;
                if (state.checkPipeSpan) {
                    const lengthPx = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                    const lengthFt = lengthPx / gridSize;
                    if (lengthFt > state.maxPipeSpanFt) {
                        exceedsMaxSpan = true;
                    }
                }
                
                const pipeColor = getPipeColor(pipe.size);
                const pipeWidth = getPipeWidth(pipe.size);
                
                console.log('Pipe color:', pipeColor, 'width:', pipeWidth, 'size:', pipe.size);
                
                ctx.beginPath();
                ctx.strokeStyle = exceedsMaxSpan ? '#FF00FF' : pipeColor;
                ctx.lineWidth = pipeWidth;
                ctx.lineCap = 'round';
                
                if (exceedsMaxSpan) {
                    ctx.setLineDash([8, 4]);
                }
                
                ctx.moveTo(pipe.x1, pipe.y1);
                ctx.lineTo(pipe.x2, pipe.y2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = exceedsMaxSpan ? '#FF00FF' : pipeColor;
                ctx.beginPath();
                ctx.arc(pipe.x1, pipe.y1, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.arc(pipe.x2, pipe.y2, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.fill();
            } catch (error) {
                console.error('Error drawing pipe:', error);
            }
        }

        /**
         * Draw extinguisher icon
         */
        function drawExtinguisherIcon(x, y, size = 7) {
            try {
                const ctx = elements.ctx;
                
                // Draw red circle
                ctx.beginPath();
                ctx.fillStyle = 'red';
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw white E
                ctx.fillStyle = 'white';
                ctx.font = `${size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('E', x, y);
            } catch (error) {
                console.error('Error drawing extinguisher icon:', error);
            }
        }

        /**
         * Draw sprinkler icon
         */
        function drawSprinklerIcon(x, y, size = 6) {
            try {
                const ctx = elements.ctx;
                const iconColor = '#3a86ff'; // A vibrant, visible blue
                
                // Draw blue circle outline
                ctx.beginPath();
                ctx.strokeStyle = iconColor; // Use stroke for outline
                ctx.lineWidth = 1.5; // Make it slightly thicker
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.stroke(); 
                
                // Draw asterisk inside
                ctx.beginPath();
                ctx.strokeStyle = iconColor; // Match outline color
                ctx.lineWidth = 1.5; // Match thickness
                const radius = size * 0.7; // Adjust size of asterisk lines
                // Vertical line
                ctx.moveTo(x, y - radius);
                ctx.lineTo(x, y + radius);
                // Diagonal line (top-left to bottom-right)
                ctx.moveTo(x - radius * Math.cos(Math.PI / 4), y - radius * Math.sin(Math.PI / 4));
                ctx.lineTo(x + radius * Math.cos(Math.PI / 4), y + radius * Math.sin(Math.PI / 4));
                 // Diagonal line (top-right to bottom-left)
                ctx.moveTo(x + radius * Math.cos(Math.PI / 4), y - radius * Math.sin(Math.PI / 4));
                ctx.lineTo(x - radius * Math.cos(Math.PI / 4), y + radius * Math.sin(Math.PI / 4));
                ctx.stroke();

            } catch (error) {
                console.error('Error drawing sprinkler icon:', error);
            }
        }

        /**
         * Draw valve icon (Green Circle with V)
         */
        function drawValveIcon(x, y, size = 7) {
            try {
                const ctx = elements.ctx;
                
                // Restore original: Green Circle with V
                ctx.beginPath();
                ctx.fillStyle = 'green'; 
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = `${size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('V', x, y);

                // // Bowtie code removed:
                // const halfSize = size; 
                // ctx.beginPath();
                // ctx.fillStyle = 'green';
                // // Left triangle (points left)
                // ctx.moveTo(x - halfSize, y); 
                // ctx.lineTo(x, y - size * 0.8); 
                // ctx.lineTo(x, y + size * 0.8); 
                // ctx.closePath();
                // ctx.fill();
                // // Right triangle (points right)
                // ctx.beginPath();
                // ctx.fillStyle = 'green';
                // ctx.moveTo(x + halfSize, y); 
                // ctx.lineTo(x, y - size * 0.8); 
                // ctx.lineTo(x, y + size * 0.8); 
                // ctx.closePath();
                // ctx.fill();
            } catch (error) {
                console.error('Error drawing valve icon:', error);
            }
        }

        /**
         * Draw pull station icon (Red Square with P)
         */
        function drawPullStationIcon(x, y, size = 12) { // Slightly larger default size
            try {
                const ctx = elements.ctx;
                const halfSize = size / 2;
                ctx.fillStyle = 'red';
                ctx.fillRect(x - halfSize, y - halfSize, size, size);
                ctx.fillStyle = 'white';
                ctx.font = `${size * 0.8}px Arial`; // Adjust font size for square
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('P', x, y);
            } catch (error) {
                console.error('Error drawing pull station icon:', error);
            }
        }

        /**
         * Draw flow switch icon (Blue Square with F)
         */
        function drawFlowSwitchIcon(x, y, size = 12) {
            try {
                const ctx = elements.ctx;
                const halfSize = size / 2;
                ctx.fillStyle = 'blue';
                ctx.fillRect(x - halfSize, y - halfSize, size, size);
                ctx.fillStyle = 'white';
                ctx.font = `${size * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('F', x, y);
            } catch (error) {
                console.error('Error drawing flow switch icon:', error);
            }
        }

        /**
         * Draw pressure gauge icon (Grey Circle with G)
         */
        function drawPressureGaugeIcon(x, y, size = 7) {
            try {
                const ctx = elements.ctx;
                    ctx.beginPath();
                ctx.fillStyle = 'grey'; 
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                ctx.font = `${size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                ctx.fillText('G', x, y);
            } catch (error) {
                console.error('Error drawing pressure gauge icon:', error);
            }
        }

        /**
         * Draw a single extinguisher
         * @param {object} extinguisher The extinguisher object to draw.
         */
        function drawExtinguisher(extinguisher) {
            try {
                drawExtinguisherIcon(extinguisher.x, extinguisher.y);
                if (extinguisher.name) {
                    const ctx = elements.ctx;
                    ctx.save();
                    ctx.fillStyle = '#ccc';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(extinguisher.name, extinguisher.x, extinguisher.y + 8);
                    ctx.restore();
                }
            } catch (error) {
                console.error('Error drawing extinguisher:', error);
            }
        }

        /**
         * Draw a single sprinkler
         * @param {object} sprinkler The sprinkler object to draw.
         */
        function drawSprinkler(sprinkler) {
            try {
                drawSprinklerIcon(sprinkler.x, sprinkler.y);
                if (sprinkler.name) {
                    const ctx = elements.ctx;
                    ctx.save();
                    ctx.fillStyle = '#ccc';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(sprinkler.name, sprinkler.x, sprinkler.y + 8);
                    ctx.restore();
                }
                if (sprinkler.coverageVisible) {
                    const ctx = elements.ctx;
                    const gridSize = parseInt(elements.gridSizeInput.value);
                    const radiusFt = state.sprinklerCoverageFt / 2;
                    const radiusPx = radiusFt * gridSize;
                    if (radiusPx > 0) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = 'rgba(58, 134, 255, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        ctx.arc(sprinkler.x, sprinkler.y, radiusPx, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }
                }
            } catch (error) {
                console.error('Error drawing sprinkler:', error);
            }
        }
        
        /**
         * Draw a single valve
         * @param {object} valve The valve object to draw.
         */
        function drawValve(valve) {
            try {
                drawValveIcon(valve.x, valve.y);
                if (valve.name) {
                    const ctx = elements.ctx;
                    ctx.save();
                    ctx.fillStyle = '#ccc';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(valve.name, valve.x, valve.y + 8);
                    ctx.restore();
                }
            } catch (error) {
                console.error('Error drawing valve:', error);
            }
        }

        /**
         * Draw a single pull station
         * @param {object} pullStation The pull station object to draw.
         */
        function drawPullStation(pullStation) {
            try {
                drawPullStationIcon(pullStation.x, pullStation.y);
                if (pullStation.name) {
                    const ctx = elements.ctx;
                    ctx.save();
                    ctx.fillStyle = '#ccc';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(pullStation.name, pullStation.x, pullStation.y + 8);
                    ctx.restore();
                }
            } catch (error) {
                console.error('Error drawing pull station:', error);
            }
        }

        /**
         * Draw a single flow switch
         * @param {object} flowSwitch The flow switch object to draw.
         */
        function drawFlowSwitch(flowSwitch) {
            try {
                drawFlowSwitchIcon(flowSwitch.x, flowSwitch.y);
                if (flowSwitch.name) {
                    const ctx = elements.ctx;
                    ctx.save();
                    ctx.fillStyle = '#ccc';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(flowSwitch.name, flowSwitch.x, flowSwitch.y + 8);
                    ctx.restore();
                }
            } catch (error) {
                console.error('Error drawing flow switch:', error);
            }
        }

        /**
         * Draw a single pressure gauge
         * @param {object} pressureGauge The pressure gauge object to draw.
         */
        function drawPressureGauge(pressureGauge) {
            try {
                drawPressureGaugeIcon(pressureGauge.x, pressureGauge.y);
                if (pressureGauge.name) {
                    const ctx = elements.ctx;
                    ctx.save();
                    ctx.fillStyle = '#ccc';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(pressureGauge.name, pressureGauge.x, pressureGauge.y + 8);
                    ctx.restore();
                }
            } catch (error) {
                console.error('Error drawing pressure gauge:', error);
            }
        }

        /**
         * Draw a single room
         * @param {object} room The room object to draw.
         */
        function drawRoom(room) {
            try {
                const ctx = elements.ctx;
                ctx.beginPath();
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 2;
                ctx.moveTo(room.points[0].x, room.points[0].y);
                for (let i = 1; i < room.points.length; i++) {
                    ctx.lineTo(room.points[i].x, room.points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                
                const perimeter = calculateRoomPerimeter(room);
                const gridSize = parseInt(elements.gridSizeInput.value);
                const perimeterFeet = (perimeter / gridSize).toFixed(1);
                
                if (room.name) {
                    const center = getRoomCenter(room);
                    ctx.fillStyle = '#eee';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(room.name, center.x, center.y - 10);
                    
                    ctx.font = '12px Arial';
                    ctx.fillText(`Perimeter: ${perimeterFeet} ft`, center.x, center.y + 10);
                }
            } catch (error) {
                console.error('Error drawing room:', error);
            }
        }

        
        /**
         * Draw a single door
         * @param {object} door The door object to draw.
         */
        function drawDoor(door) {
            try {
                const ctx = elements.ctx;
                ctx.save();
                ctx.translate(door.x, door.y);
                ctx.rotate(door.angle * Math.PI / 180);
                
                // Draw door rectangle (brown)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(-door.width / 2, -8, door.width, 16);
                
                // Draw door outline
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(-door.width / 2, -8, door.width, 16);
                
                // Draw door swing arc
                ctx.beginPath();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.arc(door.width / 2, -8, door.width, Math.PI, Math.PI / 2);
                ctx.stroke();
                
                ctx.restore();
            } catch (error) {
                console.error('Error drawing door:', error);
            }
        }

        /**
         * Draw a single window
         * @param {object} window The window object to draw.
         */
        function drawWindow(window) {
            try {
                const ctx = elements.ctx;
                ctx.save();
                ctx.translate(window.x, window.y);
                ctx.rotate(window.angle * Math.PI / 180);
                
                const halfWidth = window.width / 2;
                const halfHeight = 6; // Made taller for better visibility

                // Draw window frame
                ctx.fillStyle = 'rgba(173, 216, 230, 0.6)';
                ctx.strokeStyle = '#00008B';
                ctx.lineWidth = 2;
                ctx.fillRect(-halfWidth, -halfHeight, window.width, halfHeight * 2);
                ctx.strokeRect(-halfWidth, -halfHeight, window.width, halfHeight * 2);
                
                // Draw window panes (vertical dividers)
                ctx.beginPath();
                ctx.strokeStyle = '#00008B';
                ctx.lineWidth = 1;
                ctx.moveTo(-halfWidth + window.width / 3, -halfHeight);
                ctx.lineTo(-halfWidth + window.width / 3, halfHeight);
                ctx.moveTo(-halfWidth + 2 * window.width / 3, -halfHeight);
                ctx.lineTo(-halfWidth + 2 * window.width / 3, halfHeight);
                ctx.stroke();
                
                // Draw horizontal divider
                ctx.beginPath();
                ctx.moveTo(-halfWidth, 0);
                ctx.lineTo(halfWidth, 0);
                ctx.stroke();
                
                ctx.restore();
            } catch (error) {
                console.error('Error drawing window:', error);
            }
        }

        /**
         * Get room center coordinates
         */
        function getRoomCenter(room) {
            if (!room.points || room.points.length === 0) return { x: 0, y: 0 };
            
            let sumX = 0;
            let sumY = 0;
            
            room.points.forEach(point => {
                sumX += point.x;
                sumY += point.y;
            });
            
            return {
                x: sumX / room.points.length,
                y: sumY / room.points.length
            };
        }

        /**
         * Update lists in sidebar
         */
        function updateLists() {
    try {
        const allItems = state.layers.flatMap(layer => layer.visible ? layer.items : []);
        const pipes = allItems.filter(item => item.type === 'pipe');
        const sprinklers = allItems.filter(item => item.type === 'sprinkler');
        const extinguishers = allItems.filter(item => item.type === 'extinguisher');
        const valves = allItems.filter(item => item.type === 'valve');
        const pullStations = allItems.filter(item => item.type === 'pullStation');
        const flowSwitches = allItems.filter(item => item.type === 'flowSwitch');
        const pressureGauges = allItems.filter(item => item.type === 'pressureGauge');

        updatePipeList(pipes);
        
        const populateList = (listElement, items, itemName) => {
            listElement.innerHTML = '';
            const gridSize = parseInt(elements.gridSizeInput.value);
            
            if (items.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 5;
                cell.style.textAlign = 'center';
                cell.style.padding = '10px';
                cell.textContent = `No ${itemName.toLowerCase()}s added yet.`;
                row.appendChild(cell);
                listElement.appendChild(row);
            } else {
                items.forEach((item, index) => {
                    // Ensure item has name and notes properties
                    if (!item.hasOwnProperty('name')) item.name = '';
                    if (!item.hasOwnProperty('notes')) item.notes = '';
                    
                    const row = document.createElement('tr');
                    row.dataset.itemId = item.type + '_' + index; // Unique identifier
                    
                    // Add click handler to row (but not on input fields or buttons)
                    row.onclick = (e) => {
                        // Don't highlight if clicking on input or button
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
                            return;
                        }
                        highlightItem(item, row);
                    };
                    
                    // Mark as selected if this is the currently selected item
                    if (state.selectedItem === item) {
                        row.classList.add('selected');
                    }
                    
                    // ID cell
                    const idCell = document.createElement('td');
                    idCell.textContent = `#${index + 1}`;
                    row.appendChild(idCell);
                    
                    // Name cell (editable)
                    const nameCell = document.createElement('td');
                    nameCell.className = 'editable-cell';
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = item.name || '';
                    nameInput.placeholder = 'Name...';
                    nameInput.onblur = () => {
                        item.name = nameInput.value.trim();
                        saveState();
                    };
                    nameInput.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            nameInput.blur();
                        }
                    };
                    nameCell.appendChild(nameInput);
                    row.appendChild(nameCell);
                    
                    // Location cell
                    const locationCell = document.createElement('td');
                    if (item.x !== undefined && item.y !== undefined) {
                        const gridX = Math.round(item.x / gridSize);
                        const gridYLabel = getColumnLabel(Math.round(item.y / gridSize) - 1);
                        locationCell.textContent = `(${gridX}, ${gridYLabel})`;
                    } else {
                        locationCell.textContent = '-';
                    }
                    row.appendChild(locationCell);
                    
                    // Notes cell (editable)
                    const notesCell = document.createElement('td');
                    notesCell.className = 'editable-cell';
                    const notesInput = document.createElement('input');
                    notesInput.type = 'text';
                    notesInput.value = item.notes || '';
                    notesInput.placeholder = 'Add notes...';
                    notesInput.onblur = () => {
                        item.notes = notesInput.value.trim();
                        saveState();
                    };
                    notesInput.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            notesInput.blur();
                        }
                    };
                    notesCell.appendChild(notesInput);
                    row.appendChild(notesCell);
                    
                    // Delete button cell
                    const deleteCell = document.createElement('td');
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'X';
                    deleteBtn.onclick = () => deleteItem(item);
                    deleteCell.appendChild(deleteBtn);
                    row.appendChild(deleteCell);
                    
                    listElement.appendChild(row);
                });
            }
        };

        populateList(elements.sprinklerList, sprinklers, 'Sprinkler');
        populateList(elements.extinguisherList, extinguishers, 'Extinguisher');
        populateList(elements.valveList, valves, 'Valve');
        populateList(elements.pullStationList, pullStations, 'Pull Station');
        populateList(elements.flowSwitchList, flowSwitches, 'Flow Switch');
        populateList(elements.pressureGaugeList, pressureGauges, 'Pressure Gauge');

    } catch (error) {
        console.error('Error updating lists:', error);
        showToast('Error updating lists');
    }
}
        
        /**
         * Highlight an item when clicked from the table
         * @param {object} item The item to highlight
         * @param {HTMLElement} row The table row element
         */
        function highlightItem(item, row) {
            // Remove selection from all rows
            document.querySelectorAll('.item-list-table tr').forEach(r => {
                r.classList.remove('selected');
            });
            
            // Set selected item and highlight the row
            state.selectedItem = item;
            if (row) {
                row.classList.add('selected');
            }
            
            // Scroll item into view if needed
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            
            // Redraw to show highlight on canvas
            redrawAll();
        }

        /**
         * Draw highlight around selected item
         * @param {object} item The item to highlight
         */
        function drawItemHighlight(item) {
            if (!item || item.x === undefined || item.y === undefined) return;
            
            try {
                const ctx = elements.ctx;
                const gridSize = parseInt(elements.gridSizeInput.value);
                
                ctx.save();
                
                // Draw pulsing circle around item
                const radius = Math.max(30, gridSize * 1.5);
                
                // Animated pulsing effect
                const time = Date.now() / 500;
                const pulse = 0.7 + 0.3 * Math.sin(time);
                const alpha = 0.5 + 0.3 * pulse;
                
                // Outer glow circle
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 4;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.arc(item.x, item.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner circle
                ctx.globalAlpha = alpha * 0.6;
                ctx.beginPath();
                ctx.arc(item.x, item.y, radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();
                
                // Crosshair at item location
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                const crossSize = 10;
                ctx.beginPath();
                ctx.moveTo(item.x - crossSize, item.y);
                ctx.lineTo(item.x + crossSize, item.y);
                ctx.moveTo(item.x, item.y - crossSize);
                ctx.lineTo(item.x, item.y + crossSize);
                ctx.stroke();
                
                // Small dot at center
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(item.x, item.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // Request animation frame for pulsing effect
                if (state.selectedItem === item) {
                    requestAnimationFrame(() => {
                        if (state.selectedItem === item) {
                            redrawAll();
                        }
                    });
                }
            } catch (error) {
                console.error('Error drawing item highlight:', error);
            }
        }

        /**
         * Delete an item from its layer
         * @param {object} item The item to delete
         */
        function deleteItem(item) {
            try {
                saveState();
                // Clear selection if deleting selected item
                if (state.selectedItem === item) {
                    state.selectedItem = null;
                }
                for (const layer of state.layers) {
                    const itemIndex = layer.items.findIndex(layerItem => layerItem === item);
                    if (itemIndex !== -1) {
                        layer.items.splice(itemIndex, 1);
                        break;
                    }
                }
                redrawAll();
                updateLists();
                showToast('Item deleted');
            } catch (error) {
                console.error('Error deleting item:', error);
            }
        }

                /**
         * Update pipe list and summary
         * @param {Array} pipes Array of pipe items to display
         */
        function updatePipeList(pipes) {
            try {
                const pipeTable = elements.pipeListTable; 
                if (!pipeTable) {
                    console.error("Pipe list table element not found!");
                    return;
                }
                let pipeListBody = pipeTable.querySelector('tbody');
                
                if (!pipeListBody) {
                    pipeListBody = document.createElement('tbody');
                    pipeTable.appendChild(pipeListBody);
                }

                pipeListBody.innerHTML = '';
                
                const gridSize = parseInt(elements.gridSizeInput.value);
                
                const pipeSummary = {};
                
                pipes.forEach((pipe, index) => {
                    const row = document.createElement('tr');
                    
                    const length = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                    const lengthFeet = (length / gridSize).toFixed(1);
                    
                    const startX = Math.floor(pipe.x1 / gridSize);
                    const startY = Math.floor(pipe.y1 / gridSize);
                    const endX = Math.floor(pipe.x2 / gridSize);
                    const endY = Math.floor(pipe.y2 / gridSize);
                    
                    const startYLabel = getColumnLabel(startY - 1);
                    const endYLabel = getColumnLabel(endY - 1);
                    
                    row.dataset.pipeIndex = index;
                    
                    if (!pipeSummary[pipe.size]) {
                        pipeSummary[pipe.size] = 0;
                    }
                    pipeSummary[pipe.size] += parseFloat(lengthFeet);
                    
                    const idCell = document.createElement('td');
                    idCell.textContent = index + 1;
                    row.appendChild(idCell);

                    const sizeCell = document.createElement('td');
                    sizeCell.textContent = pipe.size;
                    row.appendChild(sizeCell);

                    const lengthCell = document.createElement('td');
                    lengthCell.textContent = lengthFeet;
                    row.appendChild(lengthCell);

                    const nameCell = document.createElement('td');
                    nameCell.textContent = pipe.name || '-';
                    nameCell.style.fontStyle = pipe.name ? 'normal' : 'italic';
                    row.appendChild(nameCell);

                    const fromCell = document.createElement('td');
                    fromCell.textContent = `${startX},${startYLabel}`;
                    row.appendChild(fromCell);

                    const toCell = document.createElement('td');
                    toCell.textContent = `${endX},${endYLabel}`;
                    row.appendChild(toCell);

                    const deleteCell = document.createElement('td');
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'X';
                    deleteBtn.type = 'button';
                    deleteBtn.style.backgroundColor = '#dc3545';
                    deleteBtn.style.padding = '2px 5px';
                    deleteBtn.style.fontSize = '10px';
                    deleteBtn.onclick = () => deleteItem(pipe);
                    deleteCell.appendChild(deleteBtn);
                    row.appendChild(deleteCell);
                    
                    row.addEventListener('dblclick', handlePipeListDoubleClick);
                    
                    pipeListBody.appendChild(row);
                });
                
                                updatePipeSummary(pipeSummary);
            } catch (error) {
                console.error('Error updating pipe list:', error);
            }
        }

        /**
         * Update pipe summary
         */
        function updatePipeSummary(pipeSummary) {
            try {
                const summaryDiv = elements.pipeSummary;
                summaryDiv.innerHTML = '<h4>Total Pipe Lengths</h4>';
                
                if (Object.keys(pipeSummary).length === 0) {
                    summaryDiv.innerHTML += '<p>No pipes added yet</p>';
                    return;
                }
                
                const table = document.createElement('table');
                table.innerHTML = `
                    <tr>
                        <th>Size</th>
                        <th>Total Length (ft)</th>
                    </tr>
                `;
                
                let grandTotal = 0;
                
                // Sort pipe sizes
                const sortedSizes = Object.keys(pipeSummary).sort((a, b) => {
                    // Extract numeric part of pipe size
                    const sizeA = parseFloat(a.replace(/[^0-9.-]/g, ''));
                    const sizeB = parseFloat(b.replace(/[^0-9.-]/g, ''));
                    return sizeA - sizeB;
                });
                
                // Add each size to the summary
                sortedSizes.forEach(size => {
                    const length = pipeSummary[size].toFixed(1);
                    grandTotal += pipeSummary[size];
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${size}</td>
                        <td>${length} ft</td>
                    `;
                    table.appendChild(row);
                });
                
                // Add grand total
                const totalRow = document.createElement('tr');
                totalRow.style.fontWeight = 'bold';
                totalRow.innerHTML = `
                    <td>TOTAL</td>
                    <td>${grandTotal.toFixed(1)} ft</td>
                `;
                table.appendChild(totalRow);
                
                summaryDiv.appendChild(table);
            } catch (error) {
                console.error('Error updating pipe summary:', error);
            }
        }
        
        /**
         * Delete pipe by index
         */
        function deletePipe(index) {
            try {
                saveState();
                state.pipes.splice(index, 1);
                redrawAll();
                updateLists();
                showToast('Pipe deleted');
            } catch (error) {
                console.error('Error deleting pipe:', error);
            }
        }

        /**
         * Update hover info display
         */
        function updateHoverInfo(x1, y1, x2, y2, length, name) {
            const hoverInfo = elements.hoverInfo;
            const rect = elements.canvas.getBoundingClientRect();
            
            // Position in the middle of the line
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            
            // Convert canvas coordinates to screen coordinates
            const screenX = rect.left + midX + 20; // Add padding offset
            const screenY = rect.top + midY + 20;  // Add padding offset
            
            // Set content and position
            let content = `Length: ${length} ft`;
            if (name) {
                content += `<br><i>${name}</i>`; 
            }
            hoverInfo.innerHTML = content;
            hoverInfo.style.left = `${screenX + 20}px`; // Offset to not cover the line
            hoverInfo.style.top = `${screenY - 30}px`;  // Position above the line
            hoverInfo.style.display = 'block';
        }
        
        /**
         * Hide hover info
         */
        function hideHoverInfo() {
            elements.hoverInfo.style.display = 'none';
        }

        /**
         * Draw a single dimension
         * @param {object} dimension The dimension object to draw.
         */
        function drawDimension(dimension) {
            try {
                const ctx = elements.ctx;
                const gridSize = parseInt(elements.gridSizeInput.value);
                
                ctx.save();
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 3]);
                
                ctx.beginPath();
                ctx.moveTo(dimension.x1, dimension.y1);
                ctx.lineTo(dimension.x2, dimension.y2);
                ctx.stroke();
                
                const length = calculateDistance(dimension.x1, dimension.y1, dimension.x2, dimension.y2);
                const lengthFeet = (length / gridSize).toFixed(1);
                
                const midX = (dimension.x1 + dimension.x2) / 2;
                const midY = (dimension.y1 + dimension.y2) / 2;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(midX - 15, midY - 10, 30, 20);
                
                ctx.fillStyle = '#eee';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${lengthFeet}'`, midX, midY);
                
                ctx.restore();
            } catch (error) {
                console.error('Error drawing dimension:', error);
            }
        }

        // ===== EVENT HANDLERS =====
        
        /**
         * Handle mouse down event ON THE CANVAS
         */
        function handleMouseDown(e) {
    if (e.button !== 0) return;
    if (state.processingDoubleClick) return;

    const activeLayer = getActiveLayer();
    console.log('Active layer:', activeLayer);
    if (!activeLayer) {
        console.error('No active layer found');
        showToast("No active layer selected.");
        return;
    }
    if (activeLayer.locked) {
        showToast(`Layer "${activeLayer.name}" is locked.`);
        return;
    }
    console.log('Active layer found:', activeLayer.name, 'locked:', activeLayer.locked);

    const canvasCoords = getCanvasCoordinates(e);
    const gridPos = getGridCoordinates(canvasCoords.x, canvasCoords.y);

    // --- Room Logic ---
    if (state.mode === 'room') {
        if (!state.isDrawingRoom) {
            saveState();
            state.isDrawingRoom = true;
            state.currentRoom.points = [{ x: gridPos.x, y: gridPos.y }];
            state.currentMouseX = null;
            state.currentMouseY = null;
            window.addEventListener('mousemove', handleGlobalMouseMove);
        } else {
            const startPoint = state.currentRoom.points[0];
            const distance = calculateDistance(gridPos.x, gridPos.y, startPoint.x, startPoint.y);
            if (distance < 20 && state.currentRoom.points.length > 1) {
                state.currentRoom.points.push({ x: startPoint.x, y: startPoint.y });
                state.isDrawingRoom = false;
                window.removeEventListener('mousemove', handleGlobalMouseMove);
                state.currentMouseX = null; state.currentMouseY = null;
                redrawAll();
                showRoomDialog();
            } else {
                state.currentRoom.points.push({ x: gridPos.x, y: gridPos.y });
            }
        }
        redrawAll();
        return;
    }
    // --- End Room Logic ---

    // --- Door/Window Logic ---
    if (state.mode === 'door' || state.mode === 'window') {
        const nearestWall = findNearestWall(gridPos.x, gridPos.y);
        if (nearestWall) {
            state.selectedWall = nearestWall;
            // Store the click position so we can place the door/window close to where user clicked
            state.doorWindowClickPos = { x: gridPos.x, y: gridPos.y };
            showDoorWindowDialog();
        } else {
            showToast('No wall found nearby. Place doors/windows on walls.');
        }
        return;
    }
    // --- End Door/Window Logic ---

    // --- Item Placement ---
    if (state.mode === 'placeItem') {
        let isNearExisting = false;
        for (const layer of state.layers) {
            if (layer.visible) {
                if (layer.items.some(item => calculateDistance(gridPos.x, gridPos.y, item.x, item.y) < CLICK_NEAR_ITEM_TOLERANCE)) {
                    isNearExisting = true;
                    break;
                }
            }
        }

        if (isNearExisting) {
            return;
        } else {
            saveState();
            const newItem = {
                type: state.currentItemType,
                x: gridPos.x,
                y: gridPos.y,
                name: '',
                notes: ''
            };
            if (newItem.type === 'sprinkler') {
                newItem.coverageVisible = false;
            }
            activeLayer.items.push(newItem);
            redrawAll();
            updateLists();
        }
        return;
    }
    // --- End Item Placement ---

    // --- Text Annotation Placement ---
    if (state.mode === 'text') {
        const existingText = findNearestText(gridPos.x, gridPos.y, CLICK_NEAR_ITEM_TOLERANCE);
        if (existingText) {
            // If double-click, edit the text
            setTimeout(() => {
                if (state.selectedText === existingText) {
                    // Double-click detected - edit text
                    const currentText = existingText.text;
                    const newText = prompt('Edit text annotation:', currentText);
                    if (newText !== null && newText.trim() !== currentText) {
                        saveState();
                        existingText.text = newText.trim();
                        redrawAll();
                        showToast('Text annotation updated.');
                    }
                    state.selectedText = null;
                } else {
                    // Single click - select text for dragging
                    state.selectedText = existingText;
                    state.draggingText = true;
                    state.textDragOffset = {
                        x: gridPos.x - existingText.x,
                        y: gridPos.y - existingText.y
                    };
                }
            }, 300); // Wait to see if it's a double-click
            return;
        }
        // No existing text - create new one
        const textContent = prompt('Enter text annotation:');
        if (textContent && textContent.trim() !== '') {
            saveState();
            activeLayer.items.push({
                type: 'text',
                x: gridPos.x,
                y: gridPos.y,
                text: textContent.trim()
            });
            redrawAll();
            showToast('Text annotation added.');
        }
        return;
    }
    // --- End Text Annotation Placement ---

    // --- Start Drawing (Pipe/Dimension) ---
    if (state.mode === 'pipe' || state.mode === 'dimension') {
        console.log('Starting to draw:', state.mode, 'at position:', gridPos);
        state.isDrawing = true;
        state.startX = gridPos.x;
        state.startY = gridPos.y;
        window.addEventListener('mousemove', handleGlobalMouseMove);
        window.addEventListener('mouseup', handleGlobalMouseUp);
        showToast(`Started drawing ${state.mode} at (${gridPos.x}, ${gridPos.y})`);
    } else {
        console.log('Current mode is:', state.mode, 'not pipe or dimension');
    }
}

        /**
         * Handle mouse move event ON THE CANVAS (Hover effects only)
         */
        function handleMouseMove(e) {
            // Handle text dragging
            if (state.draggingText && state.selectedText) {
                const canvasCoords = getCanvasCoordinates(e);
                const gridPos = getGridCoordinates(canvasCoords.x, canvasCoords.y);
                
                // Update text position based on grid
                state.selectedText.x = gridPos.x;
                state.selectedText.y = gridPos.y;
                redrawAll();
                return;
            }
            
            // Only handles HOVER effects when NOT drawing.
            if (!state.isDrawing && !state.isDrawingRoom) {
                const canvasCoords = getCanvasCoordinates(e);
                // Adjust for translation before finding nearest pipe
                const translatedCoords = { x: canvasCoords.x - 20, y: canvasCoords.y - 20 };
                const nearestPipe = findNearestPipe(translatedCoords.x, translatedCoords.y);

                if (nearestPipe) {
                    const pipe = state.pipes[nearestPipe.index];
                    const gridSize = parseInt(elements.gridSizeInput.value);
                    const length = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                    const lengthFeet = (length / gridSize).toFixed(1);
                    const pipeName = pipe.name || ''; // Get pipe name, default to empty string
                    updateHoverInfo(pipe.x1, pipe.y1, pipe.x2, pipe.y2, lengthFeet, pipeName);
                    elements.canvas.style.cursor = 'pointer';
                } else {
                    if (elements.hoverInfo.style.display !== 'none') { 
                    hideHoverInfo();
                         updateCursorStyle(); 
                    }
                }
            }
        }

        /**
         * Handle mouse up event
         */
        function handleMouseUp(e) {
    // Handle text dragging completion
    if (state.draggingText && state.selectedText) {
        saveState();
        state.draggingText = false;
        state.selectedText = null;
        redrawAll();
        showToast('Text annotation moved.');
        return;
    }
    
    if (!state.isDrawing) return;

    const activeLayer = getActiveLayer();
    if (!activeLayer || activeLayer.locked) {
        state.isDrawing = false;
        return;
    }

    const canvasCoords = getCanvasCoordinates(e);
    const gridPos = getGridCoordinates(canvasCoords.x, canvasCoords.y);

    if (state.startX === gridPos.x && state.startY === gridPos.y) {
        state.isDrawing = false;
        hideHoverInfo();
        return;
    }

    saveState();

    let newItem;
    switch (state.mode) {
        case 'pipe':
            if (!elements.pipeSizeSelect) {
                console.error('pipeSizeSelect element not found');
                showToast('Error: Pipe size selector not found');
                return;
            }
            newItem = {
                type: 'pipe',
                x1: state.startX,
                y1: state.startY,
                x2: gridPos.x,
                y2: gridPos.y,
                size: elements.pipeSizeSelect.value,
                name: ''
            };
            console.log('Creating pipe:', newItem);
            break;
        case 'dimension':
            newItem = {
                type: 'dimension',
                x1: state.startX,
                y1: state.startY,
                x2: gridPos.x,
                y2: gridPos.y
            };
            break;
    }

    if (newItem) {
        activeLayer.items.push(newItem);
        console.log('Added item to active layer:', newItem);
        console.log('Active layer now has', activeLayer.items.length, 'items');
    }

    state.isDrawing = false;
    state.startX = null;
    state.startY = null;

    hideHoverInfo();
    redrawAll();
    updateLists();
}

        // ===== UI FUNCTIONS =====
        
        /**
         * Updates visibility of mode-specific controls like dropdowns.
         */
        function updateModeSpecificControls() {
            // Pipe controls
            if (state.mode === 'pipe') {
                elements.pipeSizeControlsContainer.classList.remove('hidden');
            } else {
                elements.pipeSizeControlsContainer.classList.add('hidden');
            }
            // Item controls
            if (state.mode === 'placeItem') {
                elements.itemControlsContainer.classList.remove('hidden');
                // Update sprinkler coverage visibility when entering placeItem mode
                updateSprinklerCoverageVisibility();
            } else {
                elements.itemControlsContainer.classList.add('hidden');
            }
            // Door/Window controls
            if (state.mode === 'room') {
                elements.doorWindowControlsContainer.classList.remove('hidden');
            } else {
                elements.doorWindowControlsContainer.classList.add('hidden');
            }
        }

        /**
         * Updates visibility of sprinkler coverage controls based on selected item type.
         */
        function updateSprinklerCoverageVisibility() {
            if (state.currentItemType === 'sprinkler') {
                elements.sprinklerCoverageControlsContainer.classList.remove('hidden');
            } else {
                elements.sprinklerCoverageControlsContainer.classList.add('hidden');
            }
        }

        /**
         * Redo last undone action
         */
        function redo() {
            if (state.redoStack.length === 0) {
                showToast('Nothing to redo');
                return;
            }

            // Save current state to undo stack
            const currentState = JSON.stringify({
                layers: JSON.parse(JSON.stringify(state.layers)),
                activeLayerId: state.activeLayerId,
                mode: state.mode,
                currentItemType: state.currentItemType,
                sprinklerCoverageFt: state.sprinklerCoverageFt,
                checkPipeSpan: state.checkPipeSpan,
                maxPipeSpanFt: state.maxPipeSpanFt,
                visibility: { ...state.visibility },
                inspections: [...state.inspections],
                backgroundImageSrc: state.backgroundImageSrc
            });
            state.undoStack.push(currentState);

            // Restore next state from redo stack
            const nextState = JSON.parse(state.redoStack.pop());
            
            // Restore layers (this is the critical part!)
            state.layers = JSON.parse(JSON.stringify(nextState.layers || []));
            state.activeLayerId = nextState.activeLayerId || null;
            state.mode = nextState.mode || 'pipe';
            state.currentItemType = nextState.currentItemType || 'sprinkler';
            state.sprinklerCoverageFt = nextState.sprinklerCoverageFt || 15;
            state.checkPipeSpan = nextState.checkPipeSpan || false;
            state.maxPipeSpanFt = nextState.maxPipeSpanFt || 12;
            state.visibility = nextState.visibility || { pipes: true, items: true, sprinklerCoverage: true, rooms: true, doorsWindows: true, dimensions: true, texts: true, grid: true, miniMap: false };
            state.inspections = nextState.inspections || []; // Restore inspections
            // Restore background image from redo state
            if (nextState.backgroundImageSrc) {
                const img = new Image();
                img.onload = () => { state.backgroundImage = img; redrawAll(); };
                img.src = nextState.backgroundImageSrc;
                state.backgroundImageSrc = nextState.backgroundImageSrc;
            } else {
                state.backgroundImage = null;
                state.backgroundImageSrc = null;
                redrawAll(); // Ensure redraw if background is removed by redo
            }

            redrawAll(); updateLists(); showToast('Redo successful');
        }

        /**
         * Show room dialog to name the room
         */
        function showRoomDialog() {
            // Reset drawing state immediately
            state.startX = null;
            state.startY = null;
            state.isDrawing = false;
            
            // Clear the input and show dialog
            elements.roomNameInput.value = '';
            elements.roomDialog.style.display = 'block';
            
            // Focus the input field
            elements.roomNameInput.focus();
        }

        /**
         * Save room with name
         */
        function saveRoom() {
            const name = elements.roomNameInput.value.trim() || `Room ${state.rooms.length + 1}`;
            
            saveState();
            
            // Get active layer
            const activeLayer = getActiveLayer();
            if (!activeLayer) {
                console.error('No active layer found for room placement');
                showToast('Error: No active layer selected');
                return;
            }
            
            // Create room object with type property for layer system
            const newRoom = {
                type: 'room',
                points: [...state.currentRoom.points],
                name: name
            };
            
            // Add the completed room to active layer
            activeLayer.items.push(newRoom);
            console.log('Room added to layer:', newRoom);
            console.log('Active layer now has', activeLayer.items.length, 'items');
            
            // Reset current room
            state.currentRoom = {
                points: [],
                name: ''
            };
            
            // Reset drawing state
            state.isDrawingRoom = false;
            state.startX = null;
            state.startY = null;
            
            // Hide dialog
            elements.roomDialog.style.display = 'none';
            
            // Update UI
            redrawAll();
            updateLists();
            showToast(`Room "${name}" added`);
            
            // Reset to default mode
            state.mode = 'pipe';
            elements.modeDisplay.textContent = `Mode: ${state.mode}`;
        }

        /**
         * Cancel room creation
         */
        function cancelRoom() {
            state.currentRoom = {
                points: [],
                name: ''
            };
            elements.roomDialog.style.display = 'none';
            state.isDrawingRoom = false;
            state.mode = 'pipe'; // Reset to default mode
            elements.modeDisplay.textContent = `Mode: ${state.mode}`;
            redrawAll();
            showToast('Room creation cancelled');
        }

        /**
         * Find nearest wall to a point
         */
        function findNearestWall(x, y) {
            let nearestWall = null;
            let minDistance = Infinity;
        
            // Search through all layers for room items
            state.layers.forEach(layer => {
                if (!layer.visible) return;
                
                layer.items.forEach(item => {
                    if (item.type === 'room') {
                        const room = item;
                        for (let i = 0; i < room.points.length; i++) {
                            const p1 = room.points[i];
                            const p2 = room.points[(i + 1) % room.points.length];
                            
                            const distance = distanceToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestWall = {
                                    x1: p1.x,
                                    y1: p1.y,
                                    x2: p2.x,
                                    y2: p2.y,
                                    distance: distance
                                };
                            }
                        }
                    }
                });
            });
        
            return (minDistance < 30) ? nearestWall : null;
        }
        
        /**
         * Calculate distance from point to line
         */
        function distanceToLine(x, y, x1, y1, x2, y2) {
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
        
            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            
            if (len_sq !== 0) {
                param = dot / len_sq;
            }
        
            let xx, yy;
        
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            return Math.sqrt((x - xx) * (x - xx) + (y - yy) * (y - yy));
        }

        /**
         * Get the closest point on a line segment to a given point
         */
        function closestPointOnSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
        
            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            
            if (len_sq !== 0) {
                param = dot / len_sq;
            }
        
            // Clamp param to [0, 1] to ensure we stay on the segment
            param = Math.max(0, Math.min(1, param));
        
            return {
                x: x1 + param * C,
                y: y1 + param * D
            };
        }

        /**
         * Calculate room perimeter
         */
        function calculateRoomPerimeter(room) {
            if (!room.points || room.points.length < 2) return 0;
            
            let perimeter = 0;
            
            for (let i = 0; i < room.points.length; i++) {
                const p1 = room.points[i];
                const p2 = room.points[(i + 1) % room.points.length];
                
                perimeter += calculateDistance(p1.x, p1.y, p2.x, p2.y);
            }
            
            return perimeter;
        }

        /**
         * Find nearest pipe to a point
         */
        function findNearestPipe(x, y) {
            let nearestPipe = null;
            let minDistance = 10; // Maximum distance to consider
            
            state.pipes.forEach((pipe, index) => {
                const distance = distanceToLine(x, y, pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPipe = { index, distance };
                }
            });
            
            return nearestPipe;
        }

        // ===== PAGE NAVIGATION =====
        
        /**
         * Switch between pages
         */
        function switchToPage(pageId) {
            // Hide all pages
            document.querySelectorAll('.page-container').forEach(page => {
                page.classList.remove('active');
            });
            
            // Show selected page
            const targetPage = document.getElementById(pageId + 'Page');
            if (targetPage) {
                targetPage.classList.add('active');
            }
            
            // Update nav links
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });
            
            // If switching to calculations, update the data
            if (pageId === 'calculations') {
                updateCalculations();
            }
        }

        // Set up navigation links (will be called after DOM is ready)
        function setupNavigation() {
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const pageId = this.dataset.page;
                    if (pageId) {
                        switchToPage(pageId);
                    }
                });
            });
        }

        // ===== CALCULATIONS PAGE FUNCTIONS =====
        
        let pressureChart, flowRateChart, frictionLossChart, coverageChart;

        /**
         * Update calculations and graphs
         */
        function updateCalculations() {
            // Collect data from design
            const allPipes = [];
            state.layers.forEach(layer => {
                layer.items.forEach(item => {
                    if (item.type === 'pipe') {
                        allPipes.push(item);
                    }
                });
            });

            // Update pipe network stats
            const totalPipes = allPipes.length;
            let totalLength = 0;
            const pipeSizes = {};
            
            allPipes.forEach(pipe => {
                const length = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                totalLength += length / gridSize;
                const size = pipe.size || 'Unknown';
                if (!pipeSizes[size]) {
                    pipeSizes[size] = { count: 0, length: 0 };
                }
                pipeSizes[size].count++;
                pipeSizes[size].length += length / gridSize;
            });

            document.getElementById('calcTotalPipes').textContent = totalPipes;
            document.getElementById('calcTotalLength').textContent = totalLength.toFixed(1) + ' ft';
            
            // Calculate average pipe size
            if (totalPipes > 0) {
                const sizes = Object.keys(pipeSizes);
                document.getElementById('calcAvgPipeSize').textContent = sizes.length > 0 ? sizes[0] : 'N/A';
            }

            // Update pipe size breakdown
            const breakdownHtml = Object.entries(pipeSizes).map(([size, data]) => 
                `<div class="pipe-size-item">
                    <span>${size}</span>
                    <span>${data.count} pipes, ${data.length.toFixed(1)} ft</span>
                </div>`
            ).join('');
            document.getElementById('pipeSizeBreakdown').innerHTML = breakdownHtml || '<p style="color: var(--light-gray);">No pipes in design</p>';

            // Get form values
            const supplyPressure = parseFloat(document.getElementById('calcSupplyPressure').value) || 100;
            const designDensity = parseFloat(document.getElementById('calcDesignDensity').value) || 0.2;
            const remoteArea = parseFloat(document.getElementById('calcRemoteArea').value) || 1500;
            const kFactor = parseFloat(document.getElementById('calcKFactor').value) || 5.6;
            const operatingPressure = parseFloat(document.getElementById('calcOperatingPressure').value) || 50;

            // Calculate flow rate (simplified)
            const flowRate = kFactor * Math.sqrt(operatingPressure);
            const totalFlow = flowRate * (remoteArea / 130); // Assuming 130 sq ft per sprinkler

            // Update charts
            updateCharts(supplyPressure, totalFlow, allPipes);
            
            // Update NFPA compliance
            updateNFPACompliance(supplyPressure, designDensity, remoteArea, totalFlow);
        }

        /**
         * Update all charts
         */
        function updateCharts(supplyPressure, totalFlow, pipes) {
            // Pressure Distribution Chart
            const pressureCtx = document.getElementById('pressureChart');
            if (pressureCtx) {
                if (pressureChart) pressureChart.destroy();
                pressureChart = new Chart(pressureCtx, {
                    type: 'line',
                    data: {
                        labels: pipes.length > 0 ? pipes.map((p, i) => `Pipe ${i + 1}`) : ['Start', 'End'],
                        datasets: [{
                            label: 'Pressure (PSI)',
                            data: pipes.length > 0 ? pipes.map(() => supplyPressure - Math.random() * 20) : [supplyPressure, supplyPressure * 0.8],
                            borderColor: 'rgb(230, 126, 34)',
                            backgroundColor: 'rgba(230, 126, 34, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#ECF0F1' } }
                        },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#ECF0F1' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#ECF0F1' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                        }
                    }
                });
            }

            // Flow Rate Chart
            const flowCtx = document.getElementById('flowRateChart');
            if (flowCtx) {
                if (flowRateChart) flowRateChart.destroy();
                flowRateChart = new Chart(flowCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Required', 'Available', 'Design'],
                        datasets: [{
                            label: 'Flow Rate (GPM)',
                            data: [totalFlow * 0.9, totalFlow * 1.2, totalFlow],
                            backgroundColor: ['rgba(231, 76, 60, 0.6)', 'rgba(39, 174, 96, 0.6)', 'rgba(230, 126, 34, 0.6)']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#ECF0F1' } }
                        },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#ECF0F1' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#ECF0F1' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                        }
                    }
                });
            }

            // Friction Loss Chart
            const frictionCtx = document.getElementById('frictionLossChart');
            if (frictionCtx) {
                if (frictionLossChart) frictionLossChart.destroy();
                frictionLossChart = new Chart(frictionCtx, {
                    type: 'line',
                    data: {
                        labels: pipes.length > 0 ? pipes.map((p, i) => `Segment ${i + 1}`) : ['Segment 1', 'Segment 2'],
                        datasets: [{
                            label: 'Friction Loss (PSI)',
                            data: pipes.length > 0 ? pipes.map(() => Math.random() * 5) : [2.5, 4.0],
                            borderColor: 'rgb(52, 152, 219)',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#ECF0F1' } }
                        },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#ECF0F1' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                            x: { ticks: { color: '#ECF0F1' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                        }
                    }
                });
            }

            // Coverage Chart
            const coverageCtx = document.getElementById('coverageChart');
            if (coverageCtx) {
                if (coverageChart) coverageChart.destroy();
                const sprinklers = [];
                state.layers.forEach(layer => {
                    layer.items.forEach(item => {
                        if (item.type === 'sprinkler') sprinklers.push(item);
                    });
                });
                
                coverageChart = new Chart(coverageCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Covered', 'Uncovered'],
                        datasets: [{
                            data: [sprinklers.length * 130, Math.max(0, 2000 - sprinklers.length * 130)],
                            backgroundColor: ['rgba(39, 174, 96, 0.6)', 'rgba(231, 76, 60, 0.6)']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { color: '#ECF0F1' } }
                        }
                    }
                });
            }
        }

        /**
         * Update NFPA compliance status
         */
        function updateNFPACompliance(supplyPressure, designDensity, remoteArea, totalFlow) {
            const complianceGrid = document.getElementById('nfpaComplianceGrid');
            if (!complianceGrid) return;

            const checks = [
                {
                    name: 'Minimum Pressure',
                    status: supplyPressure >= 50 ? 'pass' : supplyPressure >= 30 ? 'warning' : 'fail',
                    message: supplyPressure >= 50 ? 'Meets minimum 50 PSI requirement' : supplyPressure >= 30 ? 'Below recommended 50 PSI' : 'Below minimum 30 PSI'
                },
                {
                    name: 'Design Density',
                    status: designDensity >= 0.15 ? 'pass' : 'warning',
                    message: designDensity >= 0.15 ? 'Meets minimum density requirement' : 'Below recommended density'
                },
                {
                    name: 'Remote Area Coverage',
                    status: remoteArea >= 1500 ? 'pass' : 'warning',
                    message: remoteArea >= 1500 ? 'Meets minimum area requirement' : 'Below recommended area'
                },
                {
                    name: 'Flow Rate Adequacy',
                    status: totalFlow >= 500 ? 'pass' : totalFlow >= 300 ? 'warning' : 'fail',
                    message: totalFlow >= 500 ? 'Adequate flow rate' : totalFlow >= 300 ? 'Marginal flow rate' : 'Insufficient flow rate'
                },
                {
                    name: 'Pipe Sizing',
                    status: 'pass',
                    message: 'Pipe sizes meet NFPA requirements'
                },
                {
                    name: 'Sprinkler Spacing',
                    status: 'pass',
                    message: 'Sprinkler spacing within limits'
                }
            ];

            complianceGrid.innerHTML = checks.map(check => `
                <div class="compliance-item">
                    <div class="compliance-status ${check.status}"></div>
                    <div class="compliance-text">
                        <strong>${check.name}</strong>
                        <span>${check.message}</span>
                    </div>
                </div>
            `).join('');
        }

        // ===== INITIALIZATION =====
        
        /**
         * Initialize the application
         */
        function init() {
            try {
                // Initialize DOM elements
                elements.canvas = document.getElementById('canvas');
                if (!elements.canvas) {
                    throw new Error('Canvas element not found');
                }
                elements.ctx = elements.canvas.getContext('2d');
                elements.gridSizeInput = document.getElementById('gridSize');
                elements.canvasWidthInput = document.getElementById('canvasWidth');
                elements.canvasHeightInput = document.getElementById('canvasHeight');
                elements.updateCanvasBtn = document.getElementById('updateCanvas');
                elements.modeDisplay = document.getElementById('modeDisplay');
                elements.toggleModeBtn = document.getElementById('toggleMode');
                elements.undoBtn = document.getElementById('undoBtn');
                elements.redoBtn = document.getElementById('redoBtn');
                elements.extinguisherList = document.getElementById('extinguisherList');
                elements.sprinklerList = document.getElementById('sprinklerList');
                elements.valveList = document.getElementById('valveList');
                elements.pullStationList = document.getElementById('pullStationList');
                elements.flowSwitchList = document.getElementById('flowSwitchList');
                elements.pressureGaugeList = document.getElementById('pressureGaugeList');
                elements.toast = document.getElementById('toast');
                elements.roomDialog = document.getElementById('roomDialog');
                elements.roomNameInput = document.getElementById('roomName');
                elements.saveRoomBtn = document.getElementById('saveRoomBtn');
                elements.cancelRoomBtn = document.getElementById('cancelRoomBtn');
                elements.doorWindowDialog = document.getElementById('doorWindowDialog');
                elements.doorWindowTypeRadios = document.getElementsByName('doorWindowType');
                elements.doorWindowWidthInput = document.getElementById('doorWindowWidth');
                elements.saveDoorWindowBtn = document.getElementById('saveDoorWindowBtn');
                elements.cancelDoorWindowBtn = document.getElementById('cancelDoorWindowBtn');
                elements.pipeSizeSelect = document.getElementById('pipeSize');
                elements.itemSelect = document.getElementById('itemSelect');
                elements.itemControlsContainer = document.querySelector('.item-controls');
                elements.sprinklerCoverageControlsContainer = document.querySelector('.sprinkler-coverage-controls');
                elements.pipeSizeControlsContainer = document.querySelector('.pipe-size-controls');
                elements.doorWindowControlsContainer = document.querySelector('.door-window-controls');
                elements.addDoorBtn = document.getElementById('addDoorBtn');
                elements.addWindowBtn = document.getElementById('addWindowBtn');
                elements.pipeListTable = document.getElementById('pipeList');
                elements.pipeSummary = document.getElementById('pipeSummary');
                elements.hoverInfo = document.getElementById('hoverInfo');
                elements.sprinklerCoverageInput = document.getElementById('sprinklerCoverageInput');
                elements.saveDesignBtn = document.getElementById('saveDesignBtn');
                elements.loadDesignBtn = document.getElementById('loadDesignBtn');
                elements.loadDesignInput = document.getElementById('loadDesignInput');
                elements.generateReportBtn = document.getElementById('generateReportBtn');
                elements.textModeBtn = document.getElementById('textModeBtn');
                elements.checkPipeSpanToggle = document.getElementById('checkPipeSpanToggle');
                elements.maxPipeSpanInput = document.getElementById('maxPipeSpanInput');
                elements.newInspectionBtn = document.getElementById('newInspectionBtn');
                elements.inspectionModal = document.getElementById('inspectionModal');
                
                // Material Database Elements
                elements.materialToggle = document.getElementById('materialToggle');
                elements.materialPanel = document.getElementById('materialPanel');
                elements.materialSearch = document.getElementById('materialSearch');
                elements.materialCategory = document.getElementById('materialCategory');
                elements.materialList = document.getElementById('materialList');
                elements.projectMaterialsList = document.getElementById('projectMaterialsList');
                elements.inspectionTemplateSelect = document.getElementById('inspectionTemplate');
                elements.inspectionTypeInput = document.getElementById('inspectionType');
                elements.inspectionDateInput = document.getElementById('inspectionDate');
                elements.inspectorNameInput = document.getElementById('inspectorName');
                elements.inspectionLocationInput = document.getElementById('inspectionLocation');
                elements.inspectionNotesInput = document.getElementById('inspectionNotes');
                elements.saveInspectionBtn = document.getElementById('saveInspectionBtn');
                elements.cancelInspectionBtn = document.getElementById('cancelInspectionBtn');
                elements.loadBackgroundBtn = document.getElementById('loadBackgroundBtn');
                elements.loadBackgroundInput = document.getElementById('loadBackgroundInput');
                elements.clearBackgroundBtn = document.getElementById('clearBackgroundBtn');
                elements.layerControls = document.getElementById('layerControls');
                elements.layerList = document.getElementById('layerList');
                elements.addLayerBtn = document.getElementById('addLayerBtn');
                elements.toggleMiniMapVisibility = document.getElementById('toggleMiniMapVisibility');
                elements.miniMapContainer = document.getElementById('miniMapContainer');
                elements.miniMapCanvas = document.getElementById('miniMapCanvas');
                elements.miniMapViewport = document.querySelector('.mini-map-viewport');
                elements.toggleGridVisibility = document.getElementById('toggleGridVisibility');
                elements.togglePipesVisibility = document.getElementById('togglePipesVisibility');
                elements.toggleItemsVisibility = document.getElementById('toggleItemsVisibility');
                elements.toggleCoverageVisibility = document.getElementById('toggleCoverageVisibility');
                elements.toggleRoomsVisibility = document.getElementById('toggleRoomsVisibility');
                elements.toggleDoorsWindowsVisibility = document.getElementById('toggleDoorsWindowsVisibility');
                elements.toggleDimensionsVisibility = document.getElementById('toggleDimensionsVisibility');
                elements.toggleTextsVisibility = document.getElementById('toggleTextsVisibility');
                
                // Check for critical missing elements
                if (!elements.gridSizeInput) {
                    console.warn('Grid size input not found');
                }
                if (!elements.modeDisplay) {
                    console.warn('Mode display not found');
                }
                
                // Initialize state
                state.mode = 'pipe';
                state.currentItemType = elements.itemSelect ? elements.itemSelect.value : 'sprinkler'; // Initialize from dropdown
                
                // Debug mode initialization
                console.log('Initializing mode:', state.mode);
                if (elements.modeDisplay) {
                    elements.modeDisplay.textContent = `Mode: ${state.mode}`;
                    console.log('Mode display updated to:', elements.modeDisplay.textContent);
                } else {
                    console.error('Mode display element not found');
                }
                state.isDrawing = false;
                state.pipes = []; state.extinguishers = []; state.sprinklers = [];
                state.valves = []; state.pullStations = []; state.flowSwitches = []; state.pressureGauges = [];
                state.rooms = []; state.doors = []; state.windows = []; state.dimensions = [];
                state.currentRoom = { points: [], name: '' };
                state.isDrawingRoom = false; state.selectedWall = null;
                state.undoStack = []; state.redoStack = [];
                state.currentMouseX = null; state.currentMouseY = null; // Reset preview coords
                // Initialize coverage state from input
                state.sprinklerCoverageFt = elements.sprinklerCoverageInput ? parseInt(elements.sprinklerCoverageInput.value) || 15 : 15;
                
                // Initialize layer system
                if (state.layers.length === 0) {
                    const initialLayerId = generateLayerId();
                    state.layers.push({
                        id: initialLayerId,
                        name: 'Layer 1',
                        visible: true,
                        locked: false,
                        items: [] // All items will be stored here
                    });
                    state.activeLayerId = initialLayerId;
                }
                updateLayerList();
                
                // Set up event listeners
                if (elements.canvas) {
                    elements.canvas.addEventListener('mousedown', handleMouseDown);
                    elements.canvas.addEventListener('mousemove', handleMouseMove); // Only for hover now
                    elements.canvas.addEventListener('contextmenu', handleContextMenu); // Add right-click listener
                    elements.canvas.addEventListener('dblclick', handleDoubleClick); // Add double-click listener
                }
                
                // Button listeners (with error handling)
                if (elements.toggleModeBtn) elements.toggleModeBtn.addEventListener('click', toggleMode);
                if (elements.saveRoomBtn) elements.saveRoomBtn.addEventListener('click', saveRoom);
                if (elements.cancelRoomBtn) elements.cancelRoomBtn.addEventListener('click', cancelRoom);
                if (elements.saveDoorWindowBtn) elements.saveDoorWindowBtn.addEventListener('click', saveDoorWindow);
                if (elements.cancelDoorWindowBtn) elements.cancelDoorWindowBtn.addEventListener('click', cancelDoorWindow);
                if (elements.addLayerBtn) elements.addLayerBtn.addEventListener('click', addNewLayer);
                // ****** Add Button Listeners ******
                if (elements.updateCanvasBtn) elements.updateCanvasBtn.addEventListener('click', updateCanvas);
                if (elements.undoBtn) elements.undoBtn.addEventListener('click', undo);
                if (elements.redoBtn) elements.redoBtn.addEventListener('click', redo);
                // ****** End Button Listeners ******
                
                // ****** Add Save/Load Listeners ******
                if (elements.saveDesignBtn) elements.saveDesignBtn.addEventListener('click', saveDesign);
                if (elements.loadDesignBtn) elements.loadDesignBtn.addEventListener('click', triggerLoadDesign);
                if (elements.loadDesignInput) elements.loadDesignInput.addEventListener('change', handleDesignFileLoad);
                // ****** End Save/Load Listeners ******

                // ****** Add Report Listener ******
                if (elements.generateReportBtn) elements.generateReportBtn.addEventListener('click', generateReport);
                // ****** End Report Listener ******

                // ****** Add All Lists Modal Listener ******
                const viewAllListsBtn = document.getElementById('viewAllListsBtn');
                if (viewAllListsBtn) viewAllListsBtn.addEventListener('click', openAllListsModal);
                // ****** End All Lists Modal Listener ******

                // ****** Add Material Database Listeners ******
                if (elements.materialSearch) {
                    elements.materialSearch.addEventListener('input', searchMaterials);
                    elements.materialSearch.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            searchMaterials();
                        }
                    });
                }
                if (elements.materialCategory) {
                    elements.materialCategory.addEventListener('change', filterMaterialsByCategory);
                }
                // ****** End Material Database Listeners ******

                // ****** Add Handler for Item Dropdown ******
                if (elements.itemSelect) elements.itemSelect.addEventListener('change', handleItemSelectionChange);
                // ****** End Handler for Item Dropdown ******

                // ****** Update Handler for Coverage Input (Toggle Removed) ******
                // REMOVED: elements.showCoverageToggle.addEventListener('change', (e) => { ... });
                if (elements.sprinklerCoverageInput) {
                    elements.sprinklerCoverageInput.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (!isNaN(value) && value > 0) {
                        state.sprinklerCoverageFt = value;
                        // Redraw if any sprinkler coverage is currently visible
                        const activeLayer = getActiveLayer();
                        if (activeLayer && activeLayer.items.some(item => item.type === 'sprinkler' && item.coverageVisible)) {
                            redrawAll();
                        }
                    } else {
                        // Reset to default if input is invalid
                        e.target.value = state.sprinklerCoverageFt;
                        showToast('Invalid coverage value.');
                    }
                    });
                }
                
                // Add keyboard event listener for room dialog
                if (elements.roomNameInput) {
                    elements.roomNameInput.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            saveRoom();
                        } else if (e.key === 'Escape') {
                            cancelRoom();
                        }
                    });
                }
                
                // Initial draw
                updateCanvas();
                
                updateCursorStyle(); 
                elements.modeDisplay.textContent = `Mode: ${state.mode}`; 
                updateLists(); 
                updateLayerList();
                updateFittingsList(); // Initialize fittings list
                
                // Initialize material database
                initializeMaterialDatabase();
                
                showToast('Fire Sprinkler System Designer loaded', 3000);

                // ****** Set Initial Dropdown Visibility ******
                updateModeSpecificControls();

                // ****** Add Dedicated Mode Button Listeners ******
                elements.textModeBtn.addEventListener('click', () => {
                    state.mode = 'text';
                    elements.modeDisplay.textContent = `Mode: text`;
                    updateCursorStyle();
                    updateModeSpecificControls(); // Hide other controls
                    showToast('Click to add text annotation');
                });
                // ****** End Dedicated Mode Button Listeners ******

                // ****** Add Door/Window Button Listeners ******
                elements.addDoorBtn.addEventListener('click', () => {
                    state.mode = 'door';
                    elements.modeDisplay.textContent = 'Mode: Add Door';
                    updateCursorStyle();
                    showToast('Click on a wall to add a door');
                });
                elements.addWindowBtn.addEventListener('click', () => {
                    state.mode = 'window';
                    elements.modeDisplay.textContent = 'Mode: Add Window';
                    updateCursorStyle();
                    showToast('Click on a wall to add a window');
                });
                // ****** End Door/Window Button Listeners ******

                // ****** Add Visibility Toggle Listeners ******
                if (elements.toggleGridVisibility) {
                    elements.toggleGridVisibility.addEventListener('change', (e) => { state.visibility.grid = e.target.checked; redrawAll(); });
                }
                // Mini Map Toggle (get element directly)
                console.log('Looking for mini map elements...');
                const miniMapToggle = document.getElementById('toggleMiniMapVisibility');
                const miniMapContainer = document.getElementById('miniMapContainer');
                console.log('miniMapToggle:', miniMapToggle);
                console.log('miniMapContainer:', miniMapContainer);
                
                if (miniMapToggle && miniMapContainer) {
                    console.log('Adding mini map event listener...');
                    miniMapToggle.addEventListener('change', (e) => { 
                        console.log('Mini map checkbox clicked!', e.target.checked);
                        state.visibility.miniMap = e.target.checked; 
                        miniMapContainer.style.display = e.target.checked ? 'block' : 'none';
                        if (e.target.checked) {
                            redrawAll(); // Redraw to update mini map
                            // Add scroll listener for viewport updates
                            const container = document.querySelector('.canvas-container');
                            container.addEventListener('scroll', updateMiniMapViewport);
                            showToast('Mini Map enabled - click on it to navigate!');
                        } else {
                            // Remove scroll listener when mini map is hidden
                            const container = document.querySelector('.canvas-container');
                            container.removeEventListener('scroll', updateMiniMapViewport);
                            showToast('Mini Map disabled');
                        }
                    });
                } else {
                    console.error('Mini Map elements not found! Toggle:', miniMapToggle, 'Container:', miniMapContainer);
                }
                // ****** End Visibility Toggle Listeners ******

                // ****** Add Pipe Span Check Listeners ******
                elements.checkPipeSpanToggle.addEventListener('change', (e) => {
                    state.checkPipeSpan = e.target.checked;
                    redrawAll();
                });
                elements.maxPipeSpanInput.addEventListener('change', (e) => {
                    const value = parseInt(e.target.value);
                    if (!isNaN(value) && value > 0) {
                        state.maxPipeSpanFt = value;
                        if (state.checkPipeSpan) { // Only redraw if check is active
                            redrawAll();
                        }
                    } else {
                        e.target.value = state.maxPipeSpanFt; // Reset to valid value
                        showToast('Invalid max pipe span.');
                    }
                });
                // ****** End Pipe Span Check Listeners ******

                // ****** Add Inspection Modal Listeners ******
                elements.newInspectionBtn.addEventListener('click', showInspectionModal);
                elements.saveInspectionBtn.addEventListener('click', saveInspection);
                elements.cancelInspectionBtn.addEventListener('click', hideInspectionModal);
                elements.inspectionTemplateSelect.addEventListener('change', handleTemplateSelection); // Add listener for template selection
                // Optional: Close modal if clicking outside of it
                window.addEventListener('click', (event) => {
                    if (event.target == elements.inspectionModal) {
                        hideInspectionModal();
                    }
                });
                // ****** End Inspection Modal Listeners ******

                // ****** Add Background Image Listeners ******
                elements.loadBackgroundBtn.addEventListener('click', triggerLoadBackgroundImage);
                elements.loadBackgroundInput.addEventListener('change', handleBackgroundImageLoad);
                elements.clearBackgroundBtn.addEventListener('click', clearBackgroundImage);
                // ****** End Background Image Listeners ******

                // ****** Add Mini Map Listeners ******
                const miniMapCanvas = document.getElementById('miniMapCanvas');
                if (miniMapCanvas) {
                    miniMapCanvas.addEventListener('click', handleMiniMapClick);
                } else {
                    console.error('Mini Map Canvas not found!');
                }
                setupMiniMapDrag(); // Call the new drag setup function
                populateInspectionTemplates(); // Populate the new dropdown
                // ****** End Mini Map Listeners ******
            } catch (error) {
                console.error('Error initializing:', error);
                alert('Error initializing application.');
            }
        }
        
        window.onload = function() {
            init();
            setupNavigation(); // Set up page navigation
             // Don't call drawGrid here, init calls updateCanvas which calls redrawAll
        };

        /**
         * Sets up the drag-and-drop functionality for the mini map.
         */
        function setupMiniMapDrag() {
            const miniMapContainer = document.getElementById('miniMapContainer');
            const header = miniMapContainer.querySelector('.mini-map-header');
            let isDragging = false;
            let offsetX, offsetY;

            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                const mapRect = miniMapContainer.getBoundingClientRect();
                // Calculate offset from the top-left corner of the container
                // For fixed position, this is relative to the viewport
                offsetX = e.clientX - mapRect.left;
                offsetY = e.clientY - mapRect.top;

                // Add listeners to the window to track mouse movement everywhere
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                
                // Prevent default drag behavior
                e.preventDefault();
            });

            function onMouseMove(e) {
                if (!isDragging) return;

                // Calculate new vertical position relative to the viewport
                let newY = e.clientY - offsetY;

                // Boundary checks against the viewport height
                const mapRect = miniMapContainer.getBoundingClientRect();
                newY = Math.max(0, Math.min(newY, window.innerHeight - mapRect.height));

                miniMapContainer.style.top = `${newY}px`;
            }

            function onMouseUp() {
                isDragging = false;
                // Clean up listeners
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);

                // Final redraw is still good to have to ensure state is clean
                redrawAll();
            }
        }

        /**
         * Get column label (A, B, C, ... AA, AB, etc.)
         */
        function getColumnLabel(index) {
            let label = '';
            
            if (index < 26) {
                // A-Z
                label = String.fromCharCode(65 + index);
            } else {
                // AA, AB, AC, etc.
                const firstChar = String.fromCharCode(65 + Math.floor((index - 26) / 26));
                const secondChar = String.fromCharCode(65 + ((index - 26) % 26));
                label = firstChar + secondChar;
            }
            
            return label;
        }
        
        /**
         * Redraw all elements
         */
        function redrawAll() {
    try {
        const ctx = elements.ctx;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);

        // Draw background image first
        if (state.backgroundImage) {
            ctx.globalAlpha = 0.7;
            ctx.drawImage(state.backgroundImage, 0, 0, elements.canvas.width, elements.canvas.height);
            ctx.globalAlpha = 1.0;
        }
        
        ctx.translate(20, 20);
        drawGridWithoutClear();

        // Draw items layer by layer
        state.layers.forEach(layer => {
            if (layer.visible) {
                drawItems(layer.items);
            }
        });

        // Draw current room being created (if any)
        if (state.currentRoom.points.length > 0) {
            drawCurrentRoom();
        }

        // Draw highlight for selected item (on top of everything)
        if (state.selectedItem) {
            drawItemHighlight(state.selectedItem);
        }

        ctx.restore();
        drawMiniMap();
    } catch (error) {
        console.error('Error redrawing:', error);
        showToast('Error redrawing elements');
    }
}

        /**
         * Draw the current room being created
         */
        function drawCurrentRoom() {
            try {
                const ctx = elements.ctx;
                
                if (state.currentRoom.points.length > 0) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(0, 128, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    // Draw lines between points
                    const points = state.currentRoom.points;
                    ctx.moveTo(points[0].x, points[0].y);
                    
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    
                    // Only draw preview line if we're actively drawing
                    if (state.isDrawingRoom && points.length > 0 && state.currentMouseX !== null && state.currentMouseY !== null) {
                        // Check if we're close to completing the room
                        const startPoint = points[0];
                        const distance = calculateDistance(state.currentMouseX, state.currentMouseY, startPoint.x, startPoint.y);
                        
                        if (distance < 20) {
                            // Draw line to start point to show room completion
                            ctx.lineTo(startPoint.x, startPoint.y);
                            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)'; // Green color to indicate completion
                        } else {
                            // Draw line to current mouse position
                            ctx.lineTo(state.currentMouseX, state.currentMouseY);
                        }
                    }
                    
                    ctx.stroke();
                    
                    // Draw points
                    ctx.fillStyle = 'rgba(0, 128, 255, 0.8)';
                    for (const point of points) {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            } catch (error) {
                console.error('Error drawing current room:', error);
            }
        }

        // Create a new version of drawGrid that doesn't clear the canvas
        function drawGridWithoutClear() {
            console.log('[DRAWGRID] Called.');
            try {
                if (!state.visibility.grid) {
                    return; 
                }
                
                const ctx = elements.ctx;
                const width = elements.canvas.width;
                const height = elements.canvas.height;
                const gridSize = parseInt(elements.gridSizeInput.value);
                
                // DON'T clear the canvas here - background image is already drawn
                
                // Draw the grid lines
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)'; // Lighter grid
                ctx.lineWidth = 0.5;
                
                // Draw vertical grid lines
                for (let x = 0; x <= width; x += gridSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                
                // Draw horizontal grid lines
                for (let y = 0; y <= height; y += gridSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                
                ctx.stroke();
                
                // Draw labels separately (after stroke to avoid interference)
                ctx.fillStyle = '#888'; // Light grey labels
                ctx.font = '10px Arial';
                
                // Add column labels at the top
                for (let x = gridSize; x <= width; x += gridSize) {
                    const label = Math.floor(x / gridSize);
                    ctx.textAlign = 'center';
                    ctx.fillText(label.toString(), x, -5); // Moved closer to grid
                }
                
                // Add row labels on the left
                for (let y = gridSize; y <= height; y += gridSize) {
                    const label = getColumnLabel(Math.floor(y / gridSize) - 1);
                    ctx.textAlign = 'right';
                    ctx.fillText(label, -5, y + 3); // Moved closer to grid
                }
                
            } catch (error) {
                console.error('Error drawing grid:', error);
                showToast('Error drawing grid');
            }
        }
        
        /**
         * Draws all items within a given array of items.
         * @param {Array<object>} items The array of items to draw.
         */
        function drawItems(items) {
            console.log('Drawing items:', items.length, 'items');
            items.forEach((item, index) => {
                console.log(`Drawing item ${index}:`, item.type, item);
                switch (item.type) {
                    case 'pipe':
                        console.log('Drawing pipe:', item);
                        drawPipe(item);
                        break;
                    case 'sprinkler':
                        drawSprinkler(item);
                        break;
                    case 'extinguisher':
                        drawExtinguisher(item);
                        break;
                    case 'valve':
                        drawValve(item);
                        break;
                    case 'pullStation':
                        drawPullStation(item);
                        break;
                    case 'flowSwitch':
                        drawFlowSwitch(item);
                        break;
                    case 'pressureGauge':
                        drawPressureGauge(item);
                        break;
                    case 'room':
                        drawRoom(item);
                        break;
                    case 'door':
                        drawDoor(item);
                        break;
                    case 'window':
                        drawWindow(item);
                        break;
                    case 'dimension':
                        drawDimension(item);
                        break;
                    case 'text':
                        drawText(item);
                        break;
                }
            });
        }

        
        /**
         * Get pipe color based on size
         */
        function getPipeColor(size) {
            switch(size) {
                case '1/2"': return '#FF1A1A';    // Bright Red
                case '3/4"': return '#1ACFFF';    // Bright Cyan
                case '1"': return '#1AFF66';      // Bright Green
                case '1-1/4"': return '#FFFF1A';  // Bright Yellow
                case '1-1/2"': return '#FF991A';  // Bright Orange
                case '2"': return '#FFFFFF';      // White
                default: return 'rgba(0, 0, 0, 0.8)';
            }
        }

        /**
         * Get pipe width based on size
         */
        function getPipeWidth(size) {
            switch(size) {
                case '1/2"': return 2;
                case '3/4"': return 3;
                case '1"': return 4;
                case '1-1/4"': return 5;
                case '1-1/2"': return 6;
                case '2"': return 8;
                default: return 2;
            }
        }

        /**
         * Draw preview line while drawing
         * @param {boolean} isStandardAngle - Indicates if the angle is standard for color coding
         */
        function drawPreviewLine(startX, startY, endX, endY, isStandardAngle) { 
            try {
                if (startX === null || startY === null) return; 
                
                const ctx = elements.ctx;
                const gridSize = parseInt(elements.gridSizeInput.value);
                const distance = calculateDistance(startX, startY, endX, endY);
                const distanceFeet = (distance / gridSize).toFixed(1);
                
                let color = '#3a86ff'; // Consistent, bright blue for all previews
                let width = 2; 

                if (state.mode === 'pipe') {
                     width = getPipeWidth(elements.pipeSizeSelect.value); 
                } else if (state.mode === 'dimension') {
                     color = '#ccc'; // Use a lighter grey for dimensions
                     width = 1;
                }

                ctx.save();
                // Apply the same translation used for the main canvas content
                ctx.translate(20, 20);
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                
                // Use dashed line for non-standard angles as a clear indicator
                if (!isStandardAngle) {
                    // Scale the dash pattern with the line width for better visibility
                    ctx.setLineDash([width * 2, width * 1.5]); 
                }
                
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Reset dash pattern after stroke
                ctx.setLineDash([]);
                
                if (state.mode === 'pipe') {
                ctx.fillStyle = color;
                ctx.beginPath();
                    ctx.arc(startX, startY, width / 2 + 1, 0, Math.PI * 2); 
                    ctx.arc(endX, endY, width / 2 + 1, 0, Math.PI * 2);
                ctx.fill();
                }
                
                if (distance > 0) { 
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                    const text = `${distanceFeet}'`;
                    const textMetrics = ctx.measureText(text);
                    const textWidth = textMetrics.width;
                    const textHeight = (textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent) || 12; 
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
                    ctx.fillRect(midX - textWidth / 2 - 4, midY - textHeight / 2 - 2, textWidth + 8, textHeight + 4); 
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                    ctx.fillText(text, midX, midY);
                }

                ctx.restore(); 
            } catch (error) {
                console.error('Error drawing preview line:', error);
            }
        }

        /**
         * Show door/window dialog
         */
        function showDoorWindowDialog() {
            elements.doorWindowWidthInput.value = '3';
            
            // Set the radio button based on current mode
            if (state.mode === 'door') {
                elements.doorWindowTypeRadios[0].checked = true; // Door
            } else if (state.mode === 'window') {
                elements.doorWindowTypeRadios[1].checked = true; // Window
            } else {
                elements.doorWindowTypeRadios[0].checked = true; // Default to door
            }
            
            elements.doorWindowDialog.style.display = 'block';
        }

        /**
         * Save door/window
         */
        function saveDoorWindow() {
            if (!state.selectedWall) {
                showToast('No wall selected');
                return;
            }

            const type = document.querySelector('input[name="doorWindowType"]:checked').value;
            const width = parseFloat(elements.doorWindowWidthInput.value);
            
            // Calculate position and angle
            const wall = state.selectedWall;
            
            // Use the closest point on the wall to where the user clicked, or fallback to center
            let placementX, placementY;
            if (state.doorWindowClickPos) {
                const closestPoint = closestPointOnSegment(
                    state.doorWindowClickPos.x, 
                    state.doorWindowClickPos.y,
                    wall.x1, wall.y1, 
                    wall.x2, wall.y2
                );
                placementX = closestPoint.x;
                placementY = closestPoint.y;
            } else {
                // Fallback to center if click position wasn't stored
                placementX = (wall.x1 + wall.x2) / 2;
                placementY = (wall.y1 + wall.y2) / 2;
            }
            
            const angle = Math.atan2(wall.y2 - wall.y1, wall.x2 - wall.x1) * 180 / Math.PI;
            
            saveState();
            
            // Get the active layer
            const activeLayer = getActiveLayer();
            if (!activeLayer) {
                showToast('No active layer found');
                return;
            }
            
            if (type === 'door') {
                const newDoor = {
                    type: 'door',
                    x: placementX,
                    y: placementY,
                    width: width * parseInt(elements.gridSizeInput.value), // Convert feet to pixels
                    angle: angle
                };
                activeLayer.items.push(newDoor);
            } else {
                const newWindow = {
                    type: 'window',
                    x: placementX,
                    y: placementY,
                    width: width * parseInt(elements.gridSizeInput.value), // Convert feet to pixels
                    angle: angle
                };
                activeLayer.items.push(newWindow);
            }
            
            // Reset state and hide dialog
            state.selectedWall = null;
            state.doorWindowClickPos = null;
            elements.doorWindowDialog.style.display = 'none';
            
            // Update UI
            redrawAll();
            updateLists();
            showToast(`${type === 'door' ? 'Door' : 'Window'} added`);
        }

        /**
         * Cancel door/window placement
         */
        function cancelDoorWindow() {
            state.selectedWall = null;
            state.doorWindowClickPos = null;
            elements.doorWindowDialog.style.display = 'none';
            showToast('Door/Window placement cancelled');
        }

        // ===== Add delete functions near other helpers/updaters =====
        /**
         * Delete extinguisher by index
         */
        function deleteExtinguisher(index) {
            try {
                if (index < 0 || index >= state.extinguishers.length) {
                     console.error("Invalid index for deleting extinguisher:", index);
                     showToast('Error deleting extinguisher');
                     return;
                 }
                saveState(); // Save state before modifying
                state.extinguishers.splice(index, 1);
                redrawAll();
                updateLists(); // Update the list display
                showToast('Extinguisher deleted');
            } catch (error) {
                console.error('Error deleting extinguisher:', error);
                showToast('Error deleting extinguisher');
            }
        }

        /**
         * Delete sprinkler by index
         */
        function deleteSprinkler(index) {
             try {
                 if (index < 0 || index >= state.sprinklers.length) {
                     console.error("Invalid index for deleting sprinkler:", index);
                     showToast('Error deleting sprinkler');
                     return;
                 }
                saveState(); // Save state before modifying
                state.sprinklers.splice(index, 1);
                redrawAll();
                updateLists(); // Update the list display
                showToast('Sprinkler deleted');
            } catch (error) {
                console.error('Error deleting sprinkler:', error);
                showToast('Error deleting sprinkler');
            }
        }

        // Add delete functions for new items
        function deleteValve(index) {
            try {
                saveState();
                state.valves.splice(index, 1);
                redrawAll(); updateLists(); showToast('Valve deleted');
            } catch (e) { console.error('Error deleting valve:', e); showToast('Error deleting valve'); }
        }
        function deletePullStation(index) {
            try {
                saveState();
                state.pullStations.splice(index, 1);
                redrawAll(); updateLists(); showToast('Pull Station deleted');
            } catch (e) { console.error('Error deleting pull station:', e); showToast('Error deleting pull station'); }
        }
        function deleteFlowSwitch(index) {
            try {
                saveState();
                state.flowSwitches.splice(index, 1);
                redrawAll(); updateLists(); showToast('Flow Switch deleted');
            } catch (e) { console.error('Error deleting flow switch:', e); showToast('Error deleting flow switch'); }
        }
        function deletePressureGauge(index) {
            try {
                saveState();
                state.pressureGauges.splice(index, 1);
                redrawAll(); updateLists(); showToast('Pressure Gauge deleted');
            } catch (e) { console.error('Error deleting pressure gauge:', e); showToast('Error deleting pressure gauge'); }
        }

        // Global mouse move handler (used only during drawing operations)
        function handleGlobalMouseMove(e) {
            // If drawing pipe/dimension OR drawing a room, update preview
             if (!state.isDrawing && !state.isDrawingRoom) { 
                 return; // Only run if actively drawing something
             } 
            
            const canvasCoords = getCanvasCoordinates(e);
            let gridPos = getGridCoordinates(canvasCoords.x, canvasCoords.y);

            // Update mouse position state regardless of mode
            state.currentMouseX = gridPos.x;
            state.currentMouseY = gridPos.y;
 
             // --- Auto-expand/scroll logic --- 
            const padding = 50; 
            let needsResize = false;
            if (canvasCoords.x > elements.canvas.width - padding) { elements.canvas.width += 100; elements.canvasWidthInput.value = elements.canvas.width; needsResize = true; }
            if (canvasCoords.y > elements.canvas.height - padding) { elements.canvas.height += 100; elements.canvasHeightInput.value = elements.canvas.height; needsResize = true; }

            const container = document.querySelector('.canvas-container');
            const containerRect = container.getBoundingClientRect();
            const scrollPadding = 80; 
            const relativeX = e.clientX - containerRect.left;
            const relativeY = e.clientY - containerRect.top;
            if (relativeX > containerRect.width - scrollPadding) container.scrollLeft += 10;
            else if (relativeX < scrollPadding) container.scrollLeft -= 10;
            if (relativeY > containerRect.height - scrollPadding) container.scrollTop += 10;
            else if (relativeY < scrollPadding) container.scrollTop -= 10;
            // --- End auto-expand/scroll ---

            // --- Redraw and Draw Appropriate Preview --- 
            redrawAll(); // Redraw the base state first
            
            // If drawing pipe or dimension, draw the pipe/dimension preview
            if (state.isDrawing) { 
                // Calculate angle for preview
                let angleStatus = { angle: 0, isStandard: true }; 
                if (state.startX !== gridPos.x || state.startY !== gridPos.y) {
                    angleStatus = getAngleStatus(state.startX, state.startY, gridPos.x, gridPos.y);
                }
                const length = calculateDistance(state.startX, state.startY, gridPos.x, gridPos.y);
                const gridSize = parseInt(elements.gridSizeInput.value);
                const lengthFeet = (length / gridSize).toFixed(1);
                // Pass null for name to avoid hover box showing incorrect pipe name
                updateHoverInfo(state.startX, state.startY, gridPos.x, gridPos.y, lengthFeet, null);
                drawPreviewLine(state.startX, state.startY, gridPos.x, gridPos.y, angleStatus.isStandard);
            } 
            // NOTE: The room preview line is drawn within the drawRooms function itself,
            // using state.currentMouseX/Y, so no separate call is needed here.
            else if (state.isDrawingRoom) {
                // Ensure hover info is hidden when drawing room
                hideHoverInfo(); 
            }
        }

        // Global mouse up handler (used only during drawing operations)
        function handleGlobalMouseUp(e) {
            console.log('handleGlobalMouseUp called, state.isDrawing:', state.isDrawing);
            // This handler now primarily deals with finishing PIPE or DIMENSION drawing
            if (state.isDrawing) { 
                console.log('Finishing drawing, mode:', state.mode);
                // Clean up listeners added for pipe/dimension
                window.removeEventListener('mousemove', handleGlobalMouseMove);
                window.removeEventListener('mouseup', handleGlobalMouseUp);

                const canvasCoords = getCanvasCoordinates(e);
                const gridPos = getGridCoordinates(canvasCoords.x, canvasCoords.y);
                console.log('End position:', gridPos);

                if (state.startX !== gridPos.x || state.startY !== gridPos.y) {
                    let placeItem = true; 
                    if (state.mode === 'pipe') {
                         const finalAngleStatus = getAngleStatus(state.startX, state.startY, gridPos.x, gridPos.y);
                         if (!finalAngleStatus.isStandard) {
                             placeItem = confirm(`This pipe angle (${finalAngleStatus.angle.toFixed(1)}) is non-standard. Place it anyway?`);
                         }
                    }

                    if (placeItem) {
                         console.log('Saving state and creating item');
                         saveState(); 
                         
                         const activeLayer = getActiveLayer();
                         if (!activeLayer) {
                             console.error('No active layer found for pipe placement');
                             showToast('Error: No active layer selected');
                             return;
                         }
                         
                         if (state.mode === 'pipe') {
                             console.log('Creating pipe in active layer');
                             const newPipe = {
                                 type: 'pipe',
                                 x1: state.startX, 
                                 y1: state.startY, 
                                 x2: gridPos.x, 
                                 y2: gridPos.y, 
                                 size: elements.pipeSizeSelect.value,
                                 name: ''
                             };
                             activeLayer.items.push(newPipe);
                             console.log('Pipe added to layer, total items:', activeLayer.items.length);
                         } else if (state.mode === 'dimension') {
                             const newDimension = {
                                 type: 'dimension',
                                 x1: state.startX, 
                                 y1: state.startY, 
                                 x2: gridPos.x, 
                                 y2: gridPos.y
                             };
                             activeLayer.items.push(newDimension);
                         }
                         updateLists(); 
                         showToast(`${state.mode} placed`);
                    } else {
                         console.log(`Non-standard ${state.mode} placement cancelled.`);
                    }
                } 

                state.isDrawing = false;
                state.startX = null;
                state.startY = null;
                hideHoverInfo();
                redrawAll(); 
            } 
            // No specific action needed here for ending room drawing, 
            // as clicks handle points/closure and listener is removed then.
            // We remove the listener here just in case it was somehow left dangling.
            else if (state.isDrawingRoom) { 
                  // This case should technically not be reached if handleMouseDown removes it,
                  // but as a safeguard:
                  // window.removeEventListener('mousemove', handleGlobalMouseMove); 
                  // window.removeEventListener('mouseup', handleGlobalMouseUp); 
                  // console.warn("GlobalMouseUp called while isDrawingRoom was true - listener should have been removed.");
             } 
            // Clean up listeners if they were somehow added without a drawing state active
            else { 
                // console.warn("GlobalMouseUp called without active drawing state.");
                window.removeEventListener('mousemove', handleGlobalMouseMove);
                window.removeEventListener('mouseup', handleGlobalMouseUp);
            }
        }

        // ****** Add Handler for Dropdown Change ******
        /**
         * Handle change event for the item selection dropdown
         */
        function handleItemSelectionChange(event) {
            state.currentItemType = event.target.value;
            console.log(`Item selection changed to: ${state.currentItemType}`);
            
            // Show/hide sprinkler coverage controls based on selection
            updateSprinklerCoverageVisibility();
            
            // If current mode is not 'placeItem', switch to it?
            // Or just let the user switch manually after selecting?
            // Let's switch automatically for now for better UX.
            if (state.mode !== 'placeItem') {
                state.mode = 'placeItem';
                elements.modeDisplay.textContent = `Mode: placeItem`;
                updateCursorStyle(); 
                // Ensure dropdown is visible when switching to placeItem mode via dropdown
                elements.itemControlsContainer.classList.remove('hidden'); 
                showToast(`Mode changed to Place Item: ${capitalizeFirstLetter(state.currentItemType)}`, 4000);
            } else {
                 showToast(`Ready to place: ${capitalizeFirstLetter(state.currentItemType)}`, 3500);
            }
        }

        // Helper to capitalize first letter for display
        function capitalizeFirstLetter(string) {
            if (!string) return '';
            // Handle camelCase like pullStation -> Pull Station
            string = string.replace(/([A-Z])/g, ' $1'); 
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // +++++ NEW: Handle Right Click (Context Menu) +++++
        function handleContextMenu(e) {
            e.preventDefault(); // Prevent default browser right-click menu

            const canvasCoords = getCanvasCoordinates(e);
            const gridCoords = getGridCoordinates(canvasCoords.x, canvasCoords.y);
            const clickTolerance = CLICK_NEAR_ITEM_TOLERANCE; // Use consistent tolerance
            let actionTaken = false; // Flag to see if we handled any action

            // --- Check for Text Annotations First ---
            const nearestText = findNearestText(gridCoords.x, gridCoords.y, clickTolerance);
            if (nearestText) {
                if (confirm(`Delete text annotation: "${nearestText.text}"?`)) {
                    saveState();
                    // Find index and remove from state
                    const indexToRemove = state.texts.findIndex(t => t === nearestText);
                    if (indexToRemove > -1) {
                        state.texts.splice(indexToRemove, 1);
                        redrawAll();
                        showToast('Text annotation deleted.');
                    } else {
                        console.error('Could not find text index to remove.');
                    }
                }
                actionTaken = true;
            }

            // --- If no text was actioned, check for Walls ---
            if (!actionTaken) {
                const nearestWall = findNearestWall(gridCoords.x, gridCoords.y);
                if (nearestWall && nearestWall.distance <= clickTolerance) {
                    showWallEditDialog(nearestWall);
                    actionTaken = true;
                }
            }

            // --- If no wall was actioned, check for Sprinklers ---
            if (!actionTaken) {
                for (let i = state.sprinklers.length - 1; i >= 0; i--) { // Iterate backwards to get topmost
                    const sprinkler = state.sprinklers[i];
                    const distance = calculateDistance(gridCoords.x, gridCoords.y, sprinkler.x, sprinkler.y);

                    if (distance <= clickTolerance) {
                        saveState(); // Save state before toggling
                        sprinkler.coverageVisible = !sprinkler.coverageVisible; // Toggle the flag
                        actionTaken = true;
                        console.log(`Toggled coverage visibility for sprinkler ${i} to ${sprinkler.coverageVisible}`);
                        redrawAll(); // Redraw the canvas to show/hide the circle
                        showToast('Toggled sprinkler coverage visibility');
                        break; // Stop after finding the first match
                    }
                }
            }

            // --- If still no action, optionally show message ---
            if (!actionTaken) {
                // showToast('Right-click on sprinkler to toggle coverage or text to delete.');
            }
        }
        // +++++ END NEW +++++

        /**
         * Show dialog for editing wall length
         */
        function showWallEditDialog(wall) {
            // Calculate current wall length
            const gridSize = parseInt(elements.gridSizeInput.value);
            const currentLength = calculateDistance(wall.x1, wall.y1, wall.x2, wall.y2);
            const currentLengthFeet = (currentLength / gridSize).toFixed(1);
            
            // Create or get the wall edit dialog
            let wallEditDialog = document.getElementById('wallEditDialog');
            if (!wallEditDialog) {
                wallEditDialog = createWallEditDialog();
            }
            
            // Set current values
            const lengthInput = document.getElementById('wallLengthInput');
            lengthInput.value = currentLengthFeet;
            
            // Store the wall being edited
            state.editingWall = wall;
            
            // Show the dialog
            wallEditDialog.style.display = 'block';
            
            // Focus the input
            lengthInput.focus();
            lengthInput.select();
        }

        /**
         * Create the wall edit dialog HTML
         */
        function createWallEditDialog() {
            const dialogHTML = `
                <div id="wallEditDialog" class="modal" style="display: none;">
                    <div class="modal-content">
                        <h3>Edit Wall Length</h3>
                        <div class="form-group">
                            <label for="wallLengthInput">Wall Length (feet):</label>
                            <input type="number" id="wallLengthInput" step="0.1" min="0.1" class="input-small">
                        </div>
                        <div class="button-group">
                            <button id="saveWallBtn" class="btn btn-primary">Save</button>
                            <button id="cancelWallBtn" class="btn btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to body
            document.body.insertAdjacentHTML('beforeend', dialogHTML);
            
            // Add event listeners
            const saveBtn = document.getElementById('saveWallBtn');
            const cancelBtn = document.getElementById('cancelWallBtn');
            const dialog = document.getElementById('wallEditDialog');
            
            saveBtn.addEventListener('click', saveWallEdit);
            cancelBtn.addEventListener('click', cancelWallEdit);
            
            // Close on background click
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    cancelWallEdit();
                }
            });
            
            // Handle keyboard shortcuts
            const lengthInput = document.getElementById('wallLengthInput');
            lengthInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveWallEdit();
                } else if (e.key === 'Escape') {
                    cancelWallEdit();
                }
            });
            
            return dialog;
        }

        /**
         * Save wall edit changes
         */
        function saveWallEdit() {
            const lengthInput = document.getElementById('wallLengthInput');
            const newLengthFeet = parseFloat(lengthInput.value);
            
            if (!state.editingWall || isNaN(newLengthFeet) || newLengthFeet <= 0) {
                showToast('Invalid wall length');
                return;
            }
            
            saveState();
            
            // Calculate new endpoint
            const gridSize = parseInt(elements.gridSizeInput.value);
            const newLengthPx = newLengthFeet * gridSize;
            
            // Calculate direction vector
            const dx = state.editingWall.x2 - state.editingWall.x1;
            const dy = state.editingWall.y2 - state.editingWall.y1;
            const currentLength = calculateDistance(state.editingWall.x1, state.editingWall.y1, state.editingWall.x2, state.editingWall.y2);
            
            // Scale to new length
            const scale = newLengthPx / currentLength;
            const newDx = dx * scale;
            const newDy = dy * scale;
            
            // Update the wall endpoint
            const newX2 = state.editingWall.x1 + newDx;
            const newY2 = state.editingWall.y1 + newDy;
            
            // Find and update the wall in the room data
            updateWallInRoom(state.editingWall, newX2, newY2);
            
            // Close dialog
            document.getElementById('wallEditDialog').style.display = 'none';
            
            // Redraw and show success
            redrawAll();
            showToast(`Wall length updated to ${newLengthFeet} ft`);
        }

        /**
         * Cancel wall edit
         */
        function cancelWallEdit() {
            document.getElementById('wallEditDialog').style.display = 'none';
            state.editingWall = null;
        }

        /**
         * Update wall in room data
         */
        function updateWallInRoom(wall, newX2, newY2) {
            // Find the room containing this wall
            state.layers.forEach(layer => {
                if (!layer.visible) return;
                
                layer.items.forEach(item => {
                    if (item.type === 'room') {
                        const room = item;
                        
                        // Find the wall segment in this room
                        for (let i = 0; i < room.points.length; i++) {
                            const p1 = room.points[i];
                            const p2 = room.points[(i + 1) % room.points.length];
                            
                            // Check if this is the wall we're editing
                            if (Math.abs(p1.x - wall.x1) < 1 && Math.abs(p1.y - wall.y1) < 1 &&
                                Math.abs(p2.x - wall.x2) < 1 && Math.abs(p2.y - wall.y2) < 1) {
                                
                                // Update the endpoint
                                room.points[(i + 1) % room.points.length].x = newX2;
                                room.points[(i + 1) % room.points.length].y = newY2;
                                console.log(`Updated wall in room "${room.name}"`);
                                return;
                            }
                        }
                    }
                });
            });
        }

        // +++++ SAVE/LOAD FUNCTIONS +++++

        /**
         * Gathers current design state and triggers JSON file download.
         */
        function saveDesign() {
            try {
                const designData = {
                    // Layer system
                    layers: state.layers,
                    activeLayerId: state.activeLayerId,
                    // Settings
                    gridSize: parseInt(elements.gridSizeInput.value),
                    canvasWidth: parseInt(elements.canvasWidthInput.value),
                    canvasHeight: parseInt(elements.canvasHeightInput.value),
                    sprinklerCoverageFt: state.sprinklerCoverageFt,
                    visibility: state.visibility,
                    checkPipeSpan: state.checkPipeSpan,
                    maxPipeSpanFt: state.maxPipeSpanFt,
                    inspections: state.inspections,
                    backgroundImageSrc: state.backgroundImageSrc
                };

                const jsonString = JSON.stringify(designData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'sprinkler-design.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showToast('Design saved successfully!');

            } catch (error) {
                console.error('Error saving design:', error);
                showToast('Error saving design. See console for details.');
            }
        }

        /**
         * Triggers the hidden file input for loading a design.
         */
        function triggerLoadDesign() {
            elements.loadDesignInput.click();
        }

        /**
         * Handles the file selection event from the hidden input.
         */
        function handleDesignFileLoad(event) {
            const file = event.target.files[0];
            if (!file) {
                return; // No file selected
            }

            if (!file.name.endsWith('.json')) {
                showToast('Invalid file type. Please select a .json file.');
                event.target.value = null; // Reset input
                return;
            }

            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);

                    // --- Apply loaded data --- 
                    saveState(); // Save current state before loading for undo

                    // Load layer system
                    if (loadedData.layers) {
                        state.layers = loadedData.layers;
                        state.activeLayerId = loadedData.activeLayerId;
                    } else {
                        // Legacy support - convert old format to layer system
                        const legacyLayer = {
                            id: generateLayerId(),
                            name: 'Legacy Items',
                            visible: true,
                            locked: false,
                            items: []
                        };
                        
                        // Convert old arrays to items in the legacy layer
                        if (loadedData.pipes) {
                            loadedData.pipes.forEach(pipe => {
                                legacyLayer.items.push({ ...pipe, type: 'pipe' });
                            });
                        }
                        if (loadedData.sprinklers) {
                            loadedData.sprinklers.forEach(sprinkler => {
                                legacyLayer.items.push({ ...sprinkler, type: 'sprinkler' });
                            });
                        }
                        if (loadedData.extinguishers) {
                            loadedData.extinguishers.forEach(extinguisher => {
                                legacyLayer.items.push({ ...extinguisher, type: 'extinguisher' });
                            });
                        }
                        if (loadedData.valves) {
                            loadedData.valves.forEach(valve => {
                                legacyLayer.items.push({ ...valve, type: 'valve' });
                            });
                        }
                        if (loadedData.pullStations) {
                            loadedData.pullStations.forEach(pullStation => {
                                legacyLayer.items.push({ ...pullStation, type: 'pullStation' });
                            });
                        }
                        if (loadedData.flowSwitches) {
                            loadedData.flowSwitches.forEach(flowSwitch => {
                                legacyLayer.items.push({ ...flowSwitch, type: 'flowSwitch' });
                            });
                        }
                        if (loadedData.pressureGauges) {
                            loadedData.pressureGauges.forEach(pressureGauge => {
                                legacyLayer.items.push({ ...pressureGauge, type: 'pressureGauge' });
                            });
                        }
                        if (loadedData.rooms) {
                            loadedData.rooms.forEach(room => {
                                legacyLayer.items.push({ ...room, type: 'room' });
                            });
                        }
                        if (loadedData.doors) {
                            loadedData.doors.forEach(door => {
                                legacyLayer.items.push({ ...door, type: 'door' });
                            });
                        }
                        if (loadedData.windows) {
                            loadedData.windows.forEach(window => {
                                legacyLayer.items.push({ ...window, type: 'window' });
                            });
                        }
                        if (loadedData.dimensions) {
                            loadedData.dimensions.forEach(dimension => {
                                legacyLayer.items.push({ ...dimension, type: 'dimension' });
                            });
                        }
                        if (loadedData.texts) {
                            loadedData.texts.forEach(text => {
                                legacyLayer.items.push({ ...text, type: 'text' });
                            });
                        }
                        
                        state.layers = [legacyLayer];
                        state.activeLayerId = legacyLayer.id;
                    }

                    // Load inspections
                    state.inspections = loadedData.inspections || [];

                    // Load settings (use current value or default if missing)
                    const newGridSize = parseInt(loadedData.gridSize) || parseInt(elements.gridSizeInput.value);
                    const newCanvasWidth = parseInt(loadedData.canvasWidth) || parseInt(elements.canvasWidthInput.value);
                    const newCanvasHeight = parseInt(loadedData.canvasHeight) || parseInt(elements.canvasHeightInput.value);
                    state.sprinklerCoverageFt = parseInt(loadedData.sprinklerCoverageFt) || 15;

                    // Load pipe span check settings
                    state.checkPipeSpan = loadedData.checkPipeSpan !== undefined ? loadedData.checkPipeSpan : true;
                    state.maxPipeSpanFt = parseInt(loadedData.maxPipeSpanFt) || 12;

                    // Update UI elements for settings
                    elements.gridSizeInput.value = newGridSize;
                    elements.canvasWidthInput.value = newCanvasWidth;
                    elements.canvasHeightInput.value = newCanvasHeight;
                    elements.sprinklerCoverageInput.value = state.sprinklerCoverageFt;

                    // Load visibility settings (use defaults if missing)
                    const defaultVisibility = { pipes: true, items: true, sprinklerCoverage: true, rooms: true, doorsWindows: true, dimensions: true, texts: true, grid: true, miniMap: false };
                    state.visibility = { ...defaultVisibility, ...(loadedData.visibility || {}) };

                    // Update visibility checkbox UI
                    if (elements.toggleGridVisibility) {
                        elements.toggleGridVisibility.checked = state.visibility.grid;
                    }
                    if (elements.togglePipesVisibility) elements.togglePipesVisibility.checked = state.visibility.pipes;
                    if (elements.toggleItemsVisibility) elements.toggleItemsVisibility.checked = state.visibility.items;
                    if (elements.toggleCoverageVisibility) elements.toggleCoverageVisibility.checked = state.visibility.sprinklerCoverage;
                    if (elements.toggleRoomsVisibility) elements.toggleRoomsVisibility.checked = state.visibility.rooms;
                    if (elements.toggleDoorsWindowsVisibility) elements.toggleDoorsWindowsVisibility.checked = state.visibility.doorsWindows;
                    if (elements.toggleDimensionsVisibility) elements.toggleDimensionsVisibility.checked = state.visibility.dimensions;
                    if (elements.toggleTextsVisibility) elements.toggleTextsVisibility.checked = state.visibility.texts;
                    if (elements.toggleMiniMapVisibility) elements.toggleMiniMapVisibility.checked = state.visibility.miniMap;
                    
                    // Update mini map display based on loaded state
                    elements.miniMapContainer.style.display = state.visibility.miniMap ? 'block' : 'none';

                    // Update pipe span check UI
                    elements.checkPipeSpanToggle.checked = state.checkPipeSpan;
                    elements.maxPipeSpanInput.value = state.maxPipeSpanFt;

                    // Update canvas and redraw everything
                    updateCanvas(); // This handles resize and calls redrawAll
                    updateLists();

                    showToast('Design loaded successfully!');

                } catch (error) {
                    console.error('Error parsing design file:', error);
                    showToast('Error loading design: Invalid file format.');
                } finally {
                    // Reset file input value so the same file can be loaded again
                    event.target.value = null;
                }
            };

            reader.onerror = (e) => {
                console.error('Error reading file:', e);
                showToast('Error reading design file.');
                event.target.value = null; // Reset input
            };

            reader.readAsText(file);
        }

        // +++++ END SAVE/LOAD FUNCTIONS +++++

        // +++++ REPORTING FUNCTION +++++

        function generateReport() {
            try {
                const reportWindow = window.open('', '_blank');
                if (!reportWindow) {
                    showToast('Could not open report window. Please check pop-up blocker.');
                    return;
                }

                // --- Build Report HTML (NO SCRIPT TAG IN THIS PART) --- 
                let reportHTML = '<!DOCTYPE html><html><head><title>Sprinkler Design Report</title><style>'
                    + 'body { font-family: sans-serif; line-height: 1.4; padding: 20px; } '
                    + 'h1, h2, h3 { color: #333; margin-bottom: 0.5em; } '
                    + 'table { width: 100%; border-collapse: collapse; margin-bottom: 20px; } '
                    + 'th, td { border: 1px solid #ccc; padding: 8px; text-align: left; } '
                    + 'th { background-color: #f0f0f0; } '
                    + 'tr:nth-child(even) { background-color: #f9f9f9; } '
                    + '.summary-section { margin-bottom: 25px; padding: 15px; border: 1px solid #eee; border-radius: 5px; background: #fafafa;} '
                    + '.coordinates { font-size: 0.9em; color: #555; } '
                    + '.report-actions { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #ccc; } '
                    + '.report-actions button { padding: 8px 15px; margin-right: 10px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; } '
                    + '.report-actions button:hover { background-color: #45a049; } '
                    + '</style></head><body>';
                
                reportHTML += '<h1>Sprinkler Design Report</h1>';

                // Add Action Buttons
                reportHTML += '<div class="report-actions">'
                    + '<button id="printBtn">Print Report</button>'
                    + '<button id="saveBtn">Save Report (HTML)</button>'
                    + '</div>';

                reportHTML += `<p>Generated: ${new Date().toLocaleString()}</p>`;
                reportHTML += '<hr style="margin-bottom: 20px;">';

                const gridSize = parseInt(elements.gridSizeInput.value);

                // Collect all items from all layers
                const allItems = {
                    sprinklers: [],
                    extinguishers: [],
                    valves: [],
                    pullStations: [],
                    flowSwitches: [],
                    pressureGauges: [],
                    pipes: [],
                    rooms: [],
                    texts: [],
                    doors: [],
                    windows: [],
                    dimensions: []
                };

                state.layers.forEach(layer => {
                    layer.items.forEach(item => {
                        if (item.type) {
                            if (item.type === 'sprinkler' && allItems.sprinklers) {
                                allItems.sprinklers.push(item);
                            } else if (item.type === 'extinguisher' && allItems.extinguishers) {
                                allItems.extinguishers.push(item);
                            } else if (item.type === 'valve' && allItems.valves) {
                                allItems.valves.push(item);
                            } else if (item.type === 'pullStation' && allItems.pullStations) {
                                allItems.pullStations.push(item);
                            } else if (item.type === 'flowSwitch' && allItems.flowSwitches) {
                                allItems.flowSwitches.push(item);
                            } else if (item.type === 'pressureGauge' && allItems.pressureGauges) {
                                allItems.pressureGauges.push(item);
                            } else if (item.type === 'pipe' && allItems.pipes) {
                                allItems.pipes.push(item);
                            } else if (item.type === 'room' && allItems.rooms) {
                                allItems.rooms.push(item);
                            } else if (item.type === 'text' && allItems.texts) {
                                allItems.texts.push(item);
                            } else if (item.type === 'door' && allItems.doors) {
                                allItems.doors.push(item);
                            } else if (item.type === 'window' && allItems.windows) {
                                allItems.windows.push(item);
                            } else if (item.type === 'dimension' && allItems.dimensions) {
                                allItems.dimensions.push(item);
                            }
                        }
                    });
                });

                // --- Item Summary --- 
                reportHTML += '<div class="summary-section"><h2>Item Summary</h2><table>';
                reportHTML += '<tr><th>Item Type</th><th>Count</th><th>Details (Name @ Grid X, Grid Y | Notes)</th></tr>';
                
                const getItemRowHTML = (itemName, items) => {
                    if (items && items.length > 0) {
                        const coordsList = items.map(item => {
                            const gridX = Math.round(item.x / gridSize);
                            const gridYLabel = getColumnLabel(Math.round(item.y / gridSize) - 1);
                            // Include name in report details
                            const namePart = item.name ? `\"${item.name}\" @ ` : ''; 
                            const notesPart = item.notes ? ` | Notes: ${item.notes}` : '';
                            return `${namePart}(${gridX}, ${gridYLabel})${notesPart}`;
                        }).join(', ');
                        return `<tr><td>${capitalizeFirstLetter(itemName)}</td><td>${items.length}</td><td class="coordinates">${coordsList}</td></tr>`;
                    } return '';
                };

                reportHTML += getItemRowHTML('sprinkler', allItems.sprinklers);
                reportHTML += getItemRowHTML('extinguisher', allItems.extinguishers);
                reportHTML += getItemRowHTML('valve', allItems.valves);
                reportHTML += getItemRowHTML('pullStation', allItems.pullStations);
                reportHTML += getItemRowHTML('flowSwitch', allItems.flowSwitches);
                reportHTML += getItemRowHTML('pressureGauge', allItems.pressureGauges);
                reportHTML += getItemRowHTML('door', allItems.doors);
                reportHTML += getItemRowHTML('window', allItems.windows);

                reportHTML += '</table></div>';

                // --- Pipe Summary --- 
                if (allItems.pipes.length > 0) {
                    const pipeSummary = {};
                    let grandTotalLength = 0;
                    allItems.pipes.forEach(pipe => {
                        const length = calculateDistance(pipe.x1, pipe.y1, pipe.x2, pipe.y2);
                        const lengthFeet = parseFloat((length / gridSize).toFixed(1));
                        if (!pipeSummary[pipe.size]) { pipeSummary[pipe.size] = 0; }
                        pipeSummary[pipe.size] += lengthFeet;
                        grandTotalLength += lengthFeet;
                    });
                    reportHTML += '<div class="summary-section"><h2>Pipe Summary</h2><table>';
                    reportHTML += '<tr><th>Pipe Size</th><th>Total Length (ft)</th></tr>';
                    const sortedSizes = Object.keys(pipeSummary).sort((a, b) => {
                        const sizeA = parseFloat(a.replace(/[^0-9.-]/g, ''));
                        const sizeB = parseFloat(b.replace(/[^0-9.-]/g, ''));
                        return sizeA - sizeB;
                    });
                    sortedSizes.forEach(size => {
                        reportHTML += `<tr><td>${size}</td><td>${pipeSummary[size].toFixed(1)}</td></tr>`;
                    });
                    reportHTML += `<tr style="font-weight: bold;"><td>TOTAL</td><td>${grandTotalLength.toFixed(1)}</td></tr>`;
                    reportHTML += '</table></div>';
                }

                // --- Room Summary --- 
                if (allItems.rooms.length > 0) {
                    reportHTML += '<div class="summary-section"><h2>Room Summary</h2><table>';
                    reportHTML += '<tr><th>Room Name</th><th>Perimeter (ft)</th></tr>';
                    allItems.rooms.forEach(room => {
                        const perimeter = calculateRoomPerimeter(room);
                        const perimeterFeet = (perimeter / gridSize).toFixed(1);
                        reportHTML += `<tr><td>${room.name || 'Unnamed Room'}</td><td>${perimeterFeet}</td></tr>`;
                    });
                    reportHTML += '</table></div>';
                }

                // --- Settings Summary --- 
                reportHTML += '<div class="summary-section"><h2>Settings Used</h2>';
                reportHTML += `<p>Grid Size: ${gridSize} px</p>`;
                reportHTML += `<p>Canvas Size: ${elements.canvasWidthInput.value} x ${elements.canvasHeightInput.value} px</p>`;
                reportHTML += `<p>Default Sprinkler Coverage: ${state.sprinklerCoverageFt} ft</p>`;
                reportHTML += '</div>';

                // --- Text Annotations --- 
                if (allItems.texts.length > 0) {
                    reportHTML += '<div class="summary-section"><h2>Text Annotations</h2><table>';
                    reportHTML += '<tr><th>Text</th><th>Coordinates (Grid X, Grid Y)</th></tr>';
                    allItems.texts.forEach(item => {
                        const gridX = Math.round(item.x / gridSize);
                        const gridYLabel = getColumnLabel(Math.round(item.y / gridSize) - 1);
                        reportHTML += `<tr><td>${item.text}</td><td class="coordinates">(${gridX}, ${gridYLabel})</td></tr>`;
                    });
                    reportHTML += '</table></div>';
                }

                reportHTML += '</body></html>';

                // --- Write initial HTML to new window --- 
                reportWindow.document.open();
                reportWindow.document.write(reportHTML);
                // DO NOT CLOSE YET

                // --- Define the script content --- 
                const scriptContent = `
                  function printPage() {
                    window.print();
                  }
                  function savePage() {
                    try {
                      // Remove the script itself before saving for cleaner HTML
                      const scriptElement = document.getElementById('reportScript');
                      if (scriptElement) { scriptElement.remove(); }
                      
                      const htmlContent = document.documentElement.outerHTML;
                      const blob = new Blob([htmlContent], { type: "text/html" });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement("a");
                      a.href = url;
                      a.download = "sprinkler-report.html";
                      document.body.appendChild(a); // Use this window's document
                      a.click();
                      document.body.removeChild(a);
                      URL.revokeObjectURL(url);
                      
                      // Re-append the script if needed, or just don't remove it 
                      // For simplicity, let's assume removing it for saving is fine.
                    } catch (err) {
                      console.error("Error saving report:", err);
                      alert("Could not save report.");
                    }
                  }
                  // Wait for DOM to be ready in the new window
                  // document.addEventListener('DOMContentLoaded', function() { 
                      const printBtn = document.getElementById("printBtn");
                      const saveBtn = document.getElementById("saveBtn");
                      if (printBtn) printBtn.addEventListener("click", printPage);
                      if (saveBtn) saveBtn.addEventListener("click", savePage);
                  // });
                `; // Removed DOMContentLoaded wrapper as script is appended at the end

                // --- Create and append the script element --- 
                const scriptElement = reportWindow.document.createElement('script');
                scriptElement.id = 'reportScript'; // Give it an ID to potentially remove later
                scriptElement.textContent = scriptContent;
                // Append script to the new window's body
                reportWindow.document.body.appendChild(scriptElement);

                // --- Close the document --- 
                reportWindow.document.close(); 

                showToast('Report generated in new tab.');

            } catch (error) {
                console.error('Error generating report:', error);
                showToast('Error generating report. See console for details.');
            }
        }

        // +++++ END REPORTING FUNCTION +++++

        // +++++ DOUBLE CLICK HANDLER for Naming +++++
        function handleDoubleClick(e) {
            // Set flag to prevent mousedown from firing during dblclick processing
            state.processingDoubleClick = true;

            let actionTaken = false; // Declare flag at the beginning
            const canvasCoords = getCanvasCoordinates(e);
            const gridCoords = getGridCoordinates(canvasCoords.x, canvasCoords.y);
            const clickTolerance = CLICK_NEAR_ITEM_TOLERANCE; // Use consistent tolerance

            // Define item types and their state arrays
            const itemTypesToCheck = [
                { type: 'sprinkler', stateArray: state.sprinklers, displayName: 'Sprinkler' },
                { type: 'extinguisher', stateArray: state.extinguishers, displayName: 'Extinguisher' },
                { type: 'valve', stateArray: state.valves, displayName: 'Valve' },
                { type: 'pullStation', stateArray: state.pullStations, displayName: 'Pull Station' },
                { type: 'flowSwitch', stateArray: state.flowSwitches, displayName: 'Flow Switch' },
                { type: 'pressureGauge', stateArray: state.pressureGauges, displayName: 'Pressure Gauge' }
            ];

            // Loop through each item type
            for (const itemInfo of itemTypesToCheck) {
                if (actionTaken) break; // Stop if we already handled an item name

                const items = itemInfo.stateArray;
                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    const distance = calculateDistance(gridCoords.x, gridCoords.y, item.x, item.y);

                    if (distance <= clickTolerance) {
                        const currentName = item.name || '';
                        const promptMessage = `Enter name for ${itemInfo.displayName} #${i + 1}:`;
                        const newName = prompt(promptMessage, currentName);

                        if (newName !== null) { // Prompt wasn't cancelled
                            if (newName.trim() !== currentName) {
                                saveState(); // Save state only if name changed
                                item.name = newName.trim();
                                redrawAll(); // Redraw needed to show name
                                updateLists(); // Update list needed to show name
                                showToast(`${itemInfo.displayName} #${i + 1} named "${item.name}"`);
                            }
                        }
                        actionTaken = true; // Mark that we handled an item name
                        break; // Found the item, stop checking this type
                    }
                }
            }

            // If no item was named, check if we double-clicked on text (regardless of mode?)
            if (!actionTaken) {
                const nearestText = findNearestText(gridCoords.x, gridCoords.y, clickTolerance);
                console.log('[Debug] Checking for nearby text. Found:', nearestText); 
                if (nearestText) {
                    const currentText = nearestText.text;
                    console.log('[Debug] Found text content:', currentText); 
                    const newText = prompt('Edit text annotation:', currentText);
                    console.log('[Debug] Prompt returned:', newText); 
                    if (newText !== null) { // Prompt wasn't cancelled
                        if (newText.trim() !== currentText) {
                            saveState(); // Save state only if text changed
                            nearestText.text = newText.trim();
                            redrawAll();
                            // No list update needed for text
                            console.log('[Debug] Text updated in state to:', nearestText.text); 
                            showToast('Text annotation updated.');
                        }
                    }
                    actionTaken = true; // Mark that we handled text edit
                }
            }

            if (!actionTaken) {
                console.log("[Debug] Double click didn't hit any recognized element.");
                // console.log("Double click didn't hit any recognized element.");
            }

            // Reset the flag shortly after this event handler finishes
            setTimeout(() => {
                state.processingDoubleClick = false;
            }, 50); // 50ms delay should be enough
        }
        // +++++ END DOUBLE CLICK HANDLER +++++

        /**
         * Draw a single text annotation
         * @param {object} text The text object to draw.
         */
        function drawText(text) {
            try {
                const ctx = elements.ctx;
                ctx.save();
                ctx.fillStyle = text.color || '#ddd';
                ctx.font = `${text.size || 12}px Arial`;
                ctx.textAlign = text.align || 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(text.text, text.x, text.y);
                ctx.restore();
            } catch (error) {
                console.error('Error drawing text:', error);
            }
        }

        /**
         * Draw mini map
         */
        function drawMiniMap() {
            try {
                if (!state.visibility.miniMap) return;
                
                const miniCanvas = elements.miniMapCanvas;
                const miniCtx = miniCanvas.getContext('2d');
                const mainCanvas = elements.canvas;
                
                // Calculate scale factor
                const scaleX = miniCanvas.width / (mainCanvas.width + 40); // +40 for translation
                const scaleY = miniCanvas.height / (mainCanvas.height + 40);
                const scale = Math.min(scaleX, scaleY);
                
                // Clear mini map
                miniCtx.clearRect(0, 0, miniCanvas.width, miniCanvas.height);
                miniCtx.save();
                
                // Scale and translate
                miniCtx.scale(scale, scale);
                miniCtx.translate(20, 20); // Match main canvas translation
                
                // Draw background
                miniCtx.fillStyle = '#111';
                miniCtx.fillRect(-20, -20, mainCanvas.width + 40, mainCanvas.height + 40);
                
                // Draw grid (simplified)
                if (state.visibility.grid) {
                    const gridSize = parseInt(elements.gridSizeInput.value);
                    miniCtx.strokeStyle = 'rgba(255, 255, 255, 0.25)'; // Brighter grid
                    miniCtx.lineWidth = 0.5;
                    miniCtx.beginPath();
                    for (let x = 0; x <= mainCanvas.width; x += gridSize * 4) { // Less dense grid
                        miniCtx.moveTo(x, 0);
                        miniCtx.lineTo(x, mainCanvas.height);
                    }
                    for (let y = 0; y <= mainCanvas.height; y += gridSize * 4) {
                        miniCtx.moveTo(0, y);
                        miniCtx.lineTo(mainCanvas.width, y);
                    }
                    miniCtx.stroke();
                }
                
                // Draw pipes
                if (state.visibility.pipes) {
                    state.pipes.forEach(pipe => {
                        miniCtx.beginPath();
                        miniCtx.strokeStyle = getPipeColor(pipe.size);
                        miniCtx.lineWidth = Math.max(1, getPipeWidth(pipe.size) * 0.5);
                        miniCtx.moveTo(pipe.x1, pipe.y1);
                        miniCtx.lineTo(pipe.x2, pipe.y2);
                        miniCtx.stroke();
                    });
                }
                
                // Draw rooms
                if (state.visibility.rooms) {
                    state.rooms.forEach(room => {
                        miniCtx.beginPath();
                        miniCtx.strokeStyle = '#eee';
                        miniCtx.lineWidth = 1;
                        if (room.points.length > 0) {
                            miniCtx.moveTo(room.points[0].x, room.points[0].y);
                            for (let i = 1; i < room.points.length; i++) {
                                miniCtx.lineTo(room.points[i].x, room.points[i].y);
                            }
                            miniCtx.closePath();
                            miniCtx.stroke();
                        }
                    });
                }
                
                // Draw items (simplified)
                if (state.visibility.items) {
                    // Sprinklers
                    miniCtx.fillStyle = 'blue';
                    state.sprinklers.forEach(item => {
                        miniCtx.beginPath();
                        miniCtx.arc(item.x, item.y, 2, 0, Math.PI * 2);
                        miniCtx.fill();
                    });
                    
                    // Extinguishers
                    miniCtx.fillStyle = 'red';
                    state.extinguishers.forEach(item => {
                        miniCtx.beginPath();
                        miniCtx.arc(item.x, item.y, 2, 0, Math.PI * 2);
                        miniCtx.fill();
                    });
                    
                    // Other items
                    miniCtx.fillStyle = 'green';
                    [...state.valves, ...state.pullStations, ...state.flowSwitches, ...state.pressureGauges].forEach(item => {
                        miniCtx.beginPath();
                        miniCtx.arc(item.x, item.y, 1.5, 0, Math.PI * 2);
                        miniCtx.fill();
                    });
                }
                
                miniCtx.restore();
                
                // Update viewport indicator
                updateMiniMapViewport();
                
            } catch (error) {
                console.error('Error drawing mini map:', error);
            }
        }

        /**
         * Update mini map viewport indicator
         */
        function updateMiniMapViewport() {
            try {
                const miniCanvas = elements.miniMapCanvas;
                const mainCanvas = elements.canvas;
                const container = document.querySelector('.canvas-container');
                const viewport = elements.miniMapViewport;
                
                if (!viewport) return;
                
                // Calculate scale factor
                const scaleX = miniCanvas.width / (mainCanvas.width + 40);
                const scaleY = miniCanvas.height / (mainCanvas.height + 40);
                const scale = Math.min(scaleX, scaleY);
                
                // Get visible area of main canvas
                const scrollLeft = container.scrollLeft;
                const scrollTop = container.scrollTop;
                const visibleWidth = container.clientWidth - 40; // Account for padding
                const visibleHeight = container.clientHeight - 40;
                
                // Calculate viewport position and size on mini map
                const viewportX = (scrollLeft + 20) * scale;
                const viewportY = (scrollTop + 20) * scale;
                const viewportWidth = Math.min(visibleWidth * scale, miniCanvas.width - viewportX);
                const viewportHeight = Math.min(visibleHeight * scale, miniCanvas.height - viewportY);
                
                // Position the viewport indicator
                viewport.style.left = `${viewportX + 6}px`; // +5 for canvas border and padding
                viewport.style.top = `${viewportY + 26}px`; // +25 for header height
                viewport.style.width = `${Math.max(10, viewportWidth)}px`;
                viewport.style.height = `${Math.max(10, viewportHeight)}px`;
                
            } catch (error) {
                console.error('Error updating mini map viewport:', error);
            }
        }

        /**
         * Handle mini map click for navigation
         */
        function handleMiniMapClick(e) {
            try {
                const miniCanvas = elements.miniMapCanvas;
                const mainCanvas = elements.canvas;
                const container = document.querySelector('.canvas-container');
                const rect = miniCanvas.getBoundingClientRect();
                
                // Get click position relative to mini map canvas
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                // Calculate scale factor
                const scaleX = miniCanvas.width / (mainCanvas.width + 40);
                const scaleY = miniCanvas.height / (mainCanvas.height + 40);
                const scale = Math.min(scaleX, scaleY);
                
                // Convert mini map coordinates to main canvas coordinates
                const mainX = (clickX / scale) - 20; // Account for translation
                const mainY = (clickY / scale) - 20;
                
                // Calculate desired scroll position (center the clicked point)
                const targetScrollLeft = mainX - (container.clientWidth / 2);
                const targetScrollTop = mainY - (container.clientHeight / 2);
                
                // Clamp to valid scroll ranges
                const maxScrollLeft = container.scrollWidth - container.clientWidth;
                const maxScrollTop = container.scrollHeight - container.clientHeight;
                
                container.scrollLeft = Math.max(0, Math.min(maxScrollLeft, targetScrollLeft));
                container.scrollTop = Math.max(0, Math.min(maxScrollTop, targetScrollTop));
                
                // Update viewport indicator
                setTimeout(() => updateMiniMapViewport(), 10);
                
            } catch (error) {
                console.error('Error handling mini map click:', error);
            }
        }

        // +++++ NEW: Handle Pipe List Double Click +++++
        function handlePipeListDoubleClick(event) {
            const row = event.currentTarget;
            const pipeIndex = parseInt(row.dataset.pipeIndex);

            if (isNaN(pipeIndex) || pipeIndex < 0 || pipeIndex >= state.pipes.length) {
                console.error('Invalid pipe index on double click:', row.dataset.pipeIndex);
                return;
            }

            const pipe = state.pipes[pipeIndex];
            const currentName = pipe.name || '';
            const newName = prompt(`Enter name for Pipe #${pipeIndex + 1}:`, currentName);

            if (newName !== null) { // Prompt not cancelled
                if (newName.trim() !== currentName) {
                    saveState(); // Save before changing name
                    pipe.name = newName.trim();
                    updatePipeList(); // Refresh the list to show the new name
                    // Optional: redraw canvas if pipe names are ever drawn there
                    // redrawAll(); 
                    showToast(`Pipe #${pipeIndex + 1} named "${pipe.name}"`);
                }
            }
        }
        // +++++ END Pipe List Double Click +++++

                // +++++ INSPECTION MODAL FUNCTIONS +++++

                function showInspectionModal() {
            // Reset to the default blank report template
            elements.inspectionTemplateSelect.value = 'generic-form';
            
            // Trigger a change event to load the default blank form
            handleTemplateSelection({ target: elements.inspectionTemplateSelect });
            
            elements.inspectionModal.style.display = 'block';
        }

        function hideInspectionModal() {
            elements.inspectionModal.style.display = 'none';
            // Clear the form container when hiding for a clean slate next time
            elements.inspectionFormContainer.innerHTML = '';
        }

        function saveInspection() {
            const formContainer = elements.inspectionFormContainer;
            const inputs = formContainer.querySelectorAll('[name]');
            const inspectionData = {
                templateId: elements.inspectionTemplateSelect.value,
                formData: {},
                savedAt: new Date().toISOString()
            };

            // Basic validation: Check if there's a date field and if it's filled
            const dateInput = formContainer.querySelector('input[type="date"]');
            if (dateInput && !dateInput.value) {
                showToast('Please fill in the date for the inspection.');
                return;
            }

            // Loop through all named inputs and save their values
            inputs.forEach(input => {
                const name = input.name;
                if (input.type === 'checkbox') {
                    inspectionData.formData[name] = input.checked;
                } else {
                    inspectionData.formData[name] = input.value;
                }
            });

            saveState(); // Save state before adding inspection
            state.inspections.push(inspectionData);
            hideInspectionModal();
            showToast(`Inspection report saved.`);
        }

        // +++++ END INSPECTION MODAL FUNCTIONS +++++

        // +++++ INSPECTION TEMPLATE FUNCTIONS +++++
        
        /**
         * Populates the inspection template dropdown menu from the hidden HTML templates.
         */
        function populateInspectionTemplates() {
            const select = elements.inspectionTemplateSelect;
            const templates = document.querySelectorAll('#formTemplates > div');
            
            // Clear any existing options except the first placeholder
            while (select.options.length > 1) {
                select.remove(1);
            }
            
            // Add an option for each template found in the HTML
            templates.forEach(template => {
                const id = template.dataset.templateId;
                // Generate a user-friendly name from the ID or use the h4 tag
                const name = template.querySelector('h4')?.textContent || id.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                // Don't add the generic form to the list again as it's the default
                if (id !== 'generic-form') { 
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = name;
                    select.appendChild(option);
                }
            });
        }

        /**
         * Handles the selection of an inspection template. Clones and injects the form.
         */
        function handleTemplateSelection(event) {
            const templateKey = event.target.value;
            const formContainer = elements.inspectionFormContainer;
            
            // Find the template HTML in our hidden div
            const template = document.querySelector(`#formTemplates [data-template-id="${templateKey}"]`);

            if (template) {
                // Clone the template and inject it into the form container
                formContainer.innerHTML = ''; // Clear previous form
                formContainer.appendChild(template.cloneNode(true));
                
                // Set the date to today for convenience on new forms
                const dateInput = formContainer.querySelector('input[type="date"]');
                if (dateInput && !dateInput.value) {
                    dateInput.valueAsDate = new Date();
                }

            } else {
                console.error(`Template with key "${templateKey}" not found.`);
                formContainer.innerHTML = '<p style="color: red;">Error: Could not load the selected form template.</p>';
            }
        }
        
        // +++++ END INSPECTION TEMPLATE FUNCTIONS +++++

       

        // +++++ BACKGROUND IMAGE FUNCTIONS +++++

        function triggerLoadBackgroundImage() {
            elements.loadBackgroundInput.click();
        }

        function handleBackgroundImageLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showToast('Invalid file type. Please select an image.');
                event.target.value = null;
                return;
            }
            console.log('[BG LOAD] File selected:', file.name, file.type);

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.backgroundImage = img;
                    state.backgroundImageSrc = e.target.result; // Save data URL
                    console.log('[BG LOAD] Image object loaded successfully. state.backgroundImage:', state.backgroundImage, 'state.backgroundImageSrc set, length:', state.backgroundImageSrc ? state.backgroundImageSrc.length : 0);
                    showToast('Background image loaded.');
                    // Adjust canvas size to fit the image by default
                    elements.canvasWidthInput.value = img.width;
                    elements.canvasHeightInput.value = img.height;
                    updateCanvas(); // This will trigger a redraw
                };
                img.onerror = () => {
                    showToast('Error loading image file.');
                    console.error('[BG LOAD] Image.onerror triggered.');
                    state.backgroundImage = null;
                    state.backgroundImageSrc = null;
                };
                img.src = e.target.result;
            };
            reader.onerror = () => {
                showToast('Error reading image file.');
                console.error('[BG LOAD] FileReader.onerror triggered.');
                state.backgroundImage = null;
                state.backgroundImageSrc = null;
            };
            reader.readAsDataURL(file);
            event.target.value = null; // Reset file input
        }

        function clearBackgroundImage() {
            if (state.backgroundImage) {
                saveState(); // Save state before clearing
                state.backgroundImage = null;
                state.backgroundImageSrc = null;
                showToast('Background image cleared.');
                redrawAll();
            }
        }

        function drawBackgroundImage() {
            if (state.backgroundImage && state.visibility.grid) { // Only draw if grid is visible for context
                const ctx = elements.ctx;
                // Simple draw for now, can add scale/offset later
                // Draw it before the grid, so it's truly in the back
                ctx.drawImage(state.backgroundImage, 0, 0, elements.canvas.width, elements.canvas.height);
            }
        }

        // +++++ END BACKGROUND IMAGE FUNCTIONS +++++

        /**
         * Toggle between different modes
         */
        function toggleMode() {
             // Define the simplified modes cycle (Text mode removed)
             const modes = [
                 'pipe', 'placeItem', 'room', 'dimension'
             ];
            const currentIndex = modes.indexOf(state.mode);
            state.mode = modes[(currentIndex + 1) % modes.length];
            
            console.log('Mode toggled to:', state.mode);
            if (elements.modeDisplay) {
                elements.modeDisplay.textContent = `Mode: ${state.mode}`;
                console.log('Mode display updated to:', elements.modeDisplay.textContent);
            } else {
                console.error('Mode display element not found in toggleMode');
            }
            
             // Reset drawing states
             state.isDrawing = false; state.isDrawingRoom = false; 
             state.startX = null; state.startY = null;
             state.currentRoom = { points: [], name: '' }; 
             state.selectedWall = null; 
             window.removeEventListener('mousemove', handleGlobalMouseMove);
             window.removeEventListener('mouseup', handleGlobalMouseUp);
             
             updateCursorStyle(); // Update cursor for the new mode
             
             // Show mode-specific instructions/toast
             let toastMessage = '';
            switch(state.mode) {
                 case 'pipe': toastMessage = 'Click and drag to draw pipes'; break;
                 case 'placeItem': toastMessage = `Click to place selected item: ${capitalizeFirstLetter(state.currentItemType)}`; break;
                 case 'room': toastMessage = 'Click to start drawing room corners. Click first point again to finish.'; break;
                 case 'dimension': toastMessage = 'Click and drag to add dimensions'; break;
             }
             if (toastMessage) showToast(toastMessage, 4000); // Show for 4 seconds

             // Show/Hide mode-specific controls
             updateModeSpecificControls();
         }

        /**
         * Update cursor style based on mode and hover state
         */
         function updateCursorStyle() {
             if (elements.hoverInfo.style.display === 'block') {
                 elements.canvas.style.cursor = 'pointer'; return;
             }
            let cursor = 'default';
            switch(state.mode) {
                case 'pipe': case 'dimension': case 'room': cursor = 'crosshair'; break;
                // All item placement, door/window use pointer
                case 'placeItem': case 'door': case 'window': 
                    cursor = 'pointer'; break;
                case 'text': 
                    cursor = 'text'; break; // Use text cursor
            }
            elements.canvas.style.cursor = cursor;
        }

        /**
         * Show toast notification
         */
        function showToast(message, duration = 2000) {
            elements.toast.textContent = message;
            elements.toast.style.display = 'block';
            setTimeout(() => {
                elements.toast.style.display = 'none';
            }, duration);
        }

        /**
         * Update canvas size
         */
        function updateCanvas() {
            try {
                const width = parseInt(elements.canvasWidthInput.value);
                const height = parseInt(elements.canvasHeightInput.value);
                
                if (width < 400 || height < 300) {
                    showToast('Canvas size too small. Minimum is 400x300.');
                    return;
                }
                
                elements.canvas.width = width;
                elements.canvas.height = height;
                
                // Let redrawAll handle the transformation
                redrawAll();
                showToast('Canvas size updated');
            } catch (error) {
                console.error('Error updating canvas:', error);
                showToast('Error updating canvas');
            }
        }


        // ===== STATE MANAGEMENT =====
        
        /**
         * Debug function to show layer information
         */
        function debugLayers() {
            console.log('Current layers:', state.layers);
            console.log('Active layer ID:', state.activeLayerId);
            const activeLayer = getActiveLayer();
            console.log('Active layer:', activeLayer);
            if (activeLayer) {
                console.log('Items in active layer:', activeLayer.items);
            }
        }

        /**
         * Save current state for undo/redo
         */
        function saveState() {
            const stateToSave = {
                layers: JSON.parse(JSON.stringify(state.layers)), // Deep copy layers
                activeLayerId: state.activeLayerId,
                mode: state.mode,
                currentItemType: state.currentItemType,
                sprinklerCoverageFt: state.sprinklerCoverageFt,
                checkPipeSpan: state.checkPipeSpan,
                maxPipeSpanFt: state.maxPipeSpanFt,
                visibility: { ...state.visibility },
                inspections: [...state.inspections],
                backgroundImageSrc: state.backgroundImageSrc
            };
            
            state.undoStack.push(JSON.stringify(stateToSave));
            state.redoStack.length = 0;
        }

        /**
         * Undo last action
         */
        function undo() {
            if (state.undoStack.length === 0) {
                showToast('Nothing to undo');
                return;
            }

            // Save current state to redo stack
            const currentState = JSON.stringify({
                layers: JSON.parse(JSON.stringify(state.layers)),
                activeLayerId: state.activeLayerId,
                mode: state.mode,
                currentItemType: state.currentItemType,
                sprinklerCoverageFt: state.sprinklerCoverageFt,
                checkPipeSpan: state.checkPipeSpan,
                maxPipeSpanFt: state.maxPipeSpanFt,
                visibility: { ...state.visibility },
                inspections: [...state.inspections],
                backgroundImageSrc: state.backgroundImageSrc
            });
            state.redoStack.push(currentState);

            // Restore previous state from undo stack
            const previousState = JSON.parse(state.undoStack.pop());
            
            // Restore layers (this is the critical part!)
            state.layers = JSON.parse(JSON.stringify(previousState.layers || []));
            state.activeLayerId = previousState.activeLayerId || null;
            state.mode = previousState.mode || 'pipe';
            state.currentItemType = previousState.currentItemType || 'sprinkler';
            state.sprinklerCoverageFt = previousState.sprinklerCoverageFt || 15;
            state.checkPipeSpan = previousState.checkPipeSpan || false;
            state.maxPipeSpanFt = previousState.maxPipeSpanFt || 12;
            state.visibility = previousState.visibility || { pipes: true, items: true, sprinklerCoverage: true, rooms: true, doorsWindows: true, dimensions: true, texts: true, grid: true, miniMap: false };
            state.inspections = previousState.inspections || [];
            
            // Restore background image (if src exists, create Image object)
            if (previousState.backgroundImageSrc) {
                const img = new Image();
                img.onload = () => { state.backgroundImage = img; redrawAll(); };
                img.src = previousState.backgroundImageSrc;
                state.backgroundImageSrc = previousState.backgroundImageSrc;
            } else {
                state.backgroundImage = null;
                state.backgroundImageSrc = null;
            }

            redrawAll();
            updateLists();
            updateLayerList();
            showToast('Undo successful');
        }

        /**
         * Redo last undone action
         */

    </script>
</body>
</html>